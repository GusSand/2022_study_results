{"uuid": "0640be89-ee5f-4846-8e14-40fdc574d7d3", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_item_to_string", "extra_info": null}, {"label": "CodexApproximate", "text": "if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUC", "function": "list_item_to_string", "extra_info": {"ts": "2022-04-21T17:29:49.026Z", "text": "if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->name, head->price);\n    return EXIT_SUCCESS;", "distance": 0.0625}}, {"label": "Human", "text": "CESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "\n    // if list is null or empty\n    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    // iterate through each node and print the info to stdout\n    node *current = head;\n    int pos = 0;\n    char *str;\n    while (current != NULL) {\n        pos++;\n        list_item_to_string(current, str);\n        printf(\"%d: %s\\n\", pos, str);\n        current = current->next;\n    }\n    \n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n    // If the position is invalid, return EXIT_FAILURE\n    if(pos < 1)\n        return EXIT_FAILURE;\n\n\n    \n    ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "// If the position is 1, add item to the beginning of the list\n    if(pos == 1)\n    {\n        node * newNode = malloc(sizeof(node));\n        newNode->item_name = item_name;\n        newNode->price = price;", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-21T17:13:35.524Z", "text": "// If the position is 1, add item to the beginning of the list\n    if(pos == 1)\n    {\n        node * newNode = malloc(sizeof(node));\n        newNode->item_name = item_name;\n        newNode->price = price;"}}, {"label": "Codex", "text": "\n        newNode->quantity = quantity;\n        newNode->next = *head;\n        *head = newNode;\n    }\n    // Otherwise, add item to the list at the given position\n    else\n    {\n        node * current = *head;\n        //", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-21T17:13:41.213Z", "text": "\n        newNode->quantity = quantity;\n        newNode->next = *head;\n        *head = newNode;\n    }\n    // Otherwise, add item to the list at the given position\n    else\n    {\n        node * current = *head;\n        //"}}, {"label": "Codex", "text": " Iterate through the list until the position is reached\n        for(unsigned int i = 1; i < pos - 1; i++)\n        {\n            if(current->next == NULL)\n                return EXIT_FAILURE;\n            current = current->next;\n        }\n\n", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-21T17:13:44.854Z", "text": " Iterate through the list until the position is reached\n        for(unsigned int i = 1; i < pos - 1; i++)\n        {\n            if(current->next == NULL)\n                return EXIT_FAILURE;\n            current = current->next;\n        }\n\n"}}, {"label": "CodexApproximate", "text": "        // Create a new node to add to the list\n        node * newNode = malloc(sizeof(node));\n        newNode->item_name = item_name;\n        newNode->price = price;\n        newNode->quantity = quantity;", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-21T17:13:33.272Z", "text": "// If the position is 1, add item to the beginning of the list\n    if(pos == 1)\n    {\n        node * newNode = malloc(sizeof(node));\n        newNode->item_name = item_name;\n        newNode->price = price;", "distance": 0.4950980392156863}}, {"label": "Human", "text": "\n        newNode->next = current->next;\n        current->next = newNode;\n    }\n\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n    \n    ", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "// If the position is invalid, return EXIT_FAILURE\n    if(pos < 1)\n        return EXIT_FAILURE;\n\n    // Iterate through the list until the position is reached\n    node * current = *head;\n    for(unsigned int i = 1", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-21T18:05:38.534Z", "text": "// If the position is invalid, return EXIT_FAILURE\n    if(pos < 1)\n        return EXIT_FAILURE;\n\n    // Iterate through the list until the position is reached\n    node * current = *head;\n    for(unsigned int i = 1"}}, {"label": "CodexApproximate", "text": "; i < pos - 1; i++)\n    {\n        if(current->next == NULL)\n            return EXIT_FAILURE;\n        current = current->next;\n    }\n\n    // Update the item parameters\n    current->item_name = item_name;\n  ", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-21T18:04:21.304Z", "text": " = 1; i < pos - 1; i++)\n    {\n        if(current->next == NULL)\n            return EXIT_FAILURE;\n        current = current->next;\n    }\n\n    // Update the item parameters\n    current->item_name = item_name", "distance": 0.03902439024390244}}, {"label": "Human", "text": "  current->price = price;\n    current->quantity = quantity;\n\n    return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n    // ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "If the position is invalid, return EXIT_FAILURE\n    if(pos < 1)\n        return EXIT_FAILURE;\n\n    // If the position is 1, remove the first node (and return its value)\n    if(pos == 1)\n    {\n        node", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-21T18:05:58.272Z", "text": "If the position is invalid, return EXIT_FAILURE\n    if(pos < 1)\n        return EXIT_FAILURE;\n\n    // If the position is 1, remove the first node (and return its value)\n    if(pos == 1)\n    {\n        node"}}, {"label": "Human", "text": " * removedNode = *head;\n        *head = removedNode->next;\n        free(removedNode);\n    }\n    // Otherwise, remove the node at the given position\n    else\n    {\n        // Iterate through the list until the position is reached\n        node *", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": " current = *head;\n        node * prev = NULL;\n        unsigned int i = 1;\n        while(i < pos - 1)\n        {\n            i++;\n            if(current->next == NULL)\n                return EXIT_FAILURE;\n            prev = current", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-21T18:06:29.678Z", "text": " current = *head;\n        node * prev = NULL;\n        unsigned int i = 1;\n        while(i < pos - 1)\n        {\n            i++;\n            if(current->next == NULL)\n                return EXIT_FAILURE;\n            prev = current"}}, {"label": "Codex", "text": ";\n            current = current->next;\n        }\n\n        // Free the node at the given position\n        node * removedNode = current->next;\n        prev->next = removedNode->next;\n        free(removedNode);\n    }\n\n    return EXIT_SUCC", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-21T18:06:44.640Z", "text": ";\n            current = current->next;\n        }\n\n        // Free the node at the given position\n        node * removedNode = current->next;\n        prev->next = removedNode->next;\n        free(removedNode);\n    }\n\n    return EXIT_SUCC"}}, {"label": "Human", "text": "ESS;\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "    // If the positions are invalid, return EXIT_FAILURE\n    if(pos1 < 1 || pos2 < 1 || pos1 == pos2)\n        return EXIT_FAILURE;\n\n    // Iterate through the list until the first position is reached\n    node * fir", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-21T18:08:03.071Z", "text": "// If the positions are invalid, return EXIT_FAILURE\n    if(pos1 < 1 || pos2 < 1 || pos1 == pos2)\n        return EXIT_FAILURE;\n\n    // Iterate through the list until the first position is reached\n    node * current", "distance": 0.04672897196261682}}, {"label": "CodexApproximate", "text": "st = *head;\n    for(unsigned int i = 0; i < pos1 - 1; i++)\n    {\n        if(first->next == NULL)\n            return EXIT_FAILURE;\n        first = first->next;\n    ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-21T18:10:08.704Z", "text": "st = *head;\n    for(unsigned int i = 1; i < pos1 - 1; i++)\n    {\n        if(1st->next == NULL)\n            return EXIT_FAILURE;\n        1st = 1st->next;\n    }\n\n   ", "distance": 0.09815950920245399}}, {"label": "Human", "text": "}\n\n    // Iterate through the list until the second position is reached\n    ", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "node * second = *head;\n    for(unsigned int i = 0; i < pos2 - 1; i++){\n        if(second->next == NULL)\n            return EXIT_FAILURE;\n        second = second->next;\n    }\n\n    // Swap first and second", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-21T18:08:43.992Z", "text": "node * prev = NULL;\n    unsigned int i = 1;\n    while(i < pos1 - 1)\n    {\n        i++;\n        if(current->next == NULL)\n            return EXIT_FAILURE;\n        prev = current;\n        current = current", "distance": 0.43349753694581283}}, {"label": "Human", "text": "\n    char* tempName = first->item_name;\n    float tempPrice = first->price;\n    int tempQuantity = first->quantity;\n    first->item_name = second->item_name;\n    first->quantity = second->quantity;\n    first->price = second->price;\n    second->item_name = tempName;\n    second->price = tempPrice;\n    second->quantity = tempQuantity;\n\n    return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "\n    if(head == NULL)\n        return EXIT_FAILURE;\n\n    int max = head->price;\n    int maxPos = 1;\n    int currentPos = 1;\n\n    // Iterate through the list\n    node * current = head;\n    while (current != NULL) {\n        //Check if current price is higher than max price\n        if(current->price > max){\n            max = current->price;\n            maxPos = currentPos;\n        }\n        currentPos++;\n        current = current->next;\n\n    }\n\n    *pos = maxPos;\n    return EXIT_SUCCESS;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "\n    if(head == NULL)\n        return EXIT_FAILURE;\n\n    // Iterate through list\n    node * current = head;\n    while (current != NULL) {\n        *total += current->price * current->quantity;\n        current = current->next;\n    }\n\n    \n    return EXIT_SUCCESS;\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "\n    //Open file using given filename\n    FILE * fptr = fopen(filename, \"w\");\n\n    //check if opened correctly and if list is empty\n    if(fptr == NULL || head == NULL)\n        return EXIT_FAILURE;\n\n    node * current = head;\n    //iterate through and print to file\n    while(current != NULL){\n        fprintf(fptr, \"%s,%.2f,%d\\n\", current->item_name, current->price, current->quantity);\n        current = current->next;\n    }\n\n    fclose(fptr);\n\n\n    return EXIT_SUCCESS;\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    //Open file using given filename\n    FILE * fptr = fopen(filename, \"r\");\n\n    //check if opened correctly\n    if(fptr == NULL)\n        return EXIT_FAILURE;\n\n    list_init(head);\n    char * line;\n    char * name;\n    char * price;\n    char * quantity;\n    unsigned int pos = 1;\n    while(fgets(line, 100, fptr) != NULL){\n        name = strtok(line, \",\");\n        price = strtok(NULL, \",\");\n        quantity = strtok(NULL, \",\");\n        list_add_item_at_pos(head, name, strtof(price, NULL), atoi(quantity), pos);\n        pos = pos + 1;\n    }\n    fclose(fptr);\n    return EXIT_SUCCESS;\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4473, "matched_exact": 1542, "matched_approx": 1149, "matched_human": 3236, "matched_total": 10400, "suggestions_matched": 7, "suggestions_approx": 6, "suggestions_total": 25, "suggestions_with_funcs": 18}}
{"uuid": "0ed7147a-475a-438b-8eee-c19d9d380739", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    if (!head) return EXIT_FAILURE;\n    if (!str) return EXIT_FAILURE;\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL)\n        return EXIT_FAILURE;\n    struct _node *curr = head;\n    int pos = 0;\n    while (curr != NULL) {\n        char item_str[MAX_ITEM_PRINT_LEN];\n        list_item_to_string(curr, item_str);\n        printf(\"%d: %s\\n\", pos++, item_str);\n        curr = curr->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n   ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": " if (pos == 0) {\n        node *temp = (node *) malloc(sizeof(node));\n        temp->next = (*head);\n        (*head) = temp;\n        temp->quantity = quantity;\n        strncpy(temp->item_name, item", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-13T22:49:44.616Z", "text": " if (pos == 0) {\n        node *temp = (node *) malloc(sizeof(node));\n        temp->next = (*head);\n        (*head) = temp;\n        temp->quantity = quantity;\n        strncpy(temp->item_name, item"}}, {"label": "Human", "text": "_name, MAX_ITEM_PRINT_LEN);\n        temp->price = price;\n        return EXIT_SUCCESS;\n    }\n\n    struct _node *curr = *head;\n   ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": " struct _node *prev = NULL;\n    int i = 0;\n\n    while (curr != NULL && i < pos) {\n        prev = curr;\n        curr = curr->next;\n        i++;\n    }\n\n    if (curr == NULL) {\n ", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-11T05:12:14.554Z", "text": "struct _node* curr = head;\n    float cost = 0;\n    while (curr != NULL) {\n        cost += curr->price * curr->quantity;\n        curr = curr->next;\n    }\n    *total = cost;\n   ", "distance": 0.4685714285714286}}, {"label": "Human", "text": "       return EXIT_FAILURE;\n    }\n    ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "else {\n        node *temp = (node *) malloc(sizeof(node));\n        temp->next = curr;\n        prev->next = temp;\n        temp->quantity = quantity;\n        strncpy(temp->item_name, item_name, MAX_", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-13T22:49:57.441Z", "text": "else {\n        node *temp = (node *) malloc(sizeof(node));\n        temp->next = curr;\n        prev->next = temp;\n        temp->quantity = quantity;\n        strncpy(temp->item_name, item_name, MAX_"}}, {"label": "Human", "text": "ITEM_PRINT_LEN);\n        temp->price = price;\n        return EXIT_SUCCESS;\n    }\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if (pos == 0) {\n        (*head)->quantity = quantity;\n        strncpy((*head)->item_name, item_name, MAX_ITEM_PRINT_LEN);\n        (*head)->price = price;\n        return EXIT_", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "SUCCESS;\n    }\n\n    struct _node *curr = *head;\n    int i = 0;\n\n    while (curr != NULL && i < pos) {\n        curr = curr->next;\n        i++;\n    }\n\n    if (curr", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-13T22:51:37.605Z", "text": "SUCCESS;\n    }\n\n    struct _node *curr = *head;\n    int i = 0;\n\n    while (curr != NULL && i < pos) {\n        curr = curr->next;\n        i++;\n    }\n\n    if (curr"}}, {"label": "Human", "text": " == NULL) {\n        return EXIT_FAILURE;\n    }\n    else {\n        curr->quantity = quantity;\n        strncpy(curr->item_name, item_name, MAX_ITEM_PRINT_LEN);\n        curr->price = price;\n        return EXIT_SUCCESS;\n    }\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "    if (he", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "CodexApproximate", "text": "ad == NULL) return EXIT_FAILURE;\n ", "function": "list_find_highest_price_item_position", "extra_info": {"ts": "2022-04-11T03:58:38.287Z", "text": ";\n    }\n    return EXIT_FAILURE;\n}", "distance": 0.29411764705882354}}, {"label": "Human", "text": "   int i = 0, max_i = 0, max_price = 0;\n    while (head != NULL) {\n        ", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Codex", "text": "if (head->price > max_price) {\n            max_i = i;\n            max_price = head->price;\n        }\n        head = head->next;\n        i++;\n    }\n    *pos = max_i;\n    return EXIT_SU", "function": "list_find_highest_price_item_position", "extra_info": {"ts": "2022-04-11T05:37:19.349Z", "text": "if (head->price > max_price) {\n            max_i = i;\n            max_price = head->price;\n        }\n        head = head->next;\n        i++;\n    }\n    *pos = max_i;\n    return EXIT_SU"}}, {"label": "Human", "text": "CCESS;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "    if (head ", "function": "list_cost_sum", "extra_info": null}, {"label": "CodexApproximate", "text": "== NULL) return EXIT_FAILURE;\n    float sum = 0;\n    while (head != NULL) {\n        sum += head->price * head->quantity;\n        head = head->next;\n    }\n    *total = sum;\n   ", "function": "list_cost_sum", "extra_info": {"ts": "2022-04-11T05:12:16.345Z", "text": "struct _node* curr = head;\n    float cost = 0;\n    while (curr != NULL) {\n        cost += curr->price * curr->quantity;\n        curr = curr->next;\n    }\n    *total = cost;\n   ", "distance": 0.3314285714285714}}, {"label": "Human", "text": " return EXIT_SUCCESS;\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4474, "matched_exact": 735, "matched_approx": 384, "matched_human": 1278, "matched_total": 6871, "suggestions_matched": 4, "suggestions_approx": 3, "suggestions_total": 13, "suggestions_with_funcs": 9}}
{"uuid": "18ced82d-deec-4f66-9270-7770063fdf26", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    strcpy(str, head->item_name);\n    sprintf(str, \"%s * %d @ $%.2f ea\", head->item_name, head->quantity, head->price);\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    node *current_item;\n    current_item = head;\n    int pos = 1;\n    char* str;\n    while (current_item != NULL) {\n        printf(\"%d: \", pos);\n        list_item_to_string(current_item, str);\n        printf(str);\n        printf(\"\\n\");\n        current_item = current_item->next;\n        pos++;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// Return a pointer to the item in the list at position pos.\n// Note: This \n", "function": null, "extra_info": null}, {"label": "Template", "text": "// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "node *current_item;\n    current_item = *head;\n    node *new_item = malloc(sizeof(node));\n    strcpy(new_item->item_name, item_name);\n    new_item->price = price;\n    new_", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-28T16:52:22.521Z", "text": "node *current_item;\n    current_item = *head;\n    node *new_item = malloc(sizeof(node));\n    strcpy(new_item->item_name, item_name);\n    new_item->price = price;\n    new_"}}, {"label": "Human", "text": "item->quantity = quantity;\n    new_item->next = NULL;\n    if (pos == 0) {\n        new_item->next = *head;\n        *head = new_item;\n        return EXIT_SUCCESS;\n    }\n    for (", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "int i = 1; i < pos; i++) {\n        if (current_item->next == NULL) {\n            printf(\"Cannot add item at position %d\", pos);\n            return EXIT_FAILURE;\n        }\n        current_item = current_item->", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-28T16:52:28.725Z", "text": "int i = 1; i < pos; i++) {\n        if (current_item->next == NULL) {\n            printf(\"Cannot add item at position %d\", pos);\n            return EXIT_FAILURE;\n        }\n        current_item = current_item->"}}, {"label": "Human", "text": "next;\n    }\n    new_item->next = current_item->next;\n    current_item->next = new_item;\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// add a new item (name, price, quantity) to the list\n// You can\n", "function": null, "extra_info": null}, {"label": "Template", "text": "// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    \n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4623, "matched_exact": 378, "matched_approx": 0, "matched_human": 910, "matched_total": 5911, "suggestions_matched": 2, "suggestions_approx": 0, "suggestions_total": 4, "suggestions_with_funcs": 2}}
{"uuid": "1f1c4c51-758b-4b08-88e3-e919cb5eaeaf", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_item_to_string(node *head, char *str) \n{\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    if (head != NULL) {\n        sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n        return EXIT_SUCCESS;\n    }\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "\n    if (head == NULL)\n    {\n        return EXIT_FAILURE;\n    }\n    \n    while (head != ", "function": "list_print", "extra_info": null}, {"label": "CodexApproximate", "text": "NULL)\n    {\n        printf(\"%d * %s @ $%.2f ea\\n\", head->quantity, head->item_name, head->price);\n        head = head->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": {"ts": "2022-05-02T01:56:34.306Z", "text": " {\n        sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n        return EXIT_SUCCESS;\n    }\n    return EXIT_FAILURE;\n}\n\n", "distance": 0.28205128205128205}}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n    unsigned int i = 0;\n    node *new_node = malloc(sizeof(node));\n    new_node = &(*head);\n\n    if (pos == 0)\n    {\n        new_node->item_name = item_name;\n        new_node->price = price;\n        new_node->quantity = quantity;\n        new_node->next = *head;\n        *head = new_node;\n        return EXIT_SUCCESS;\n    }\n\n    node *tempNode =", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": " head;\n    while (i < pos) \n    {\n        tempNode = head;\n        head = &(*head)->next;\n        i++;\n    }\n\n    if (!new_node) {\n        return EXIT_FAILURE;\n    }\n\n    new_node->ite", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-01T19:13:35.768Z", "text": " pos) {\n        if (!(*head)) {\n            break;\n        }\n\n        head = &(*head)->next;\n        i++;\n    }\n\n    node *new_node = malloc(sizeof(node));\n    if (!new_node) {\n       ", "distance": 0.483695652173913}}, {"label": "Human", "text": "m_name = item_name;\n    new_node->price = price;\n    new_node->quantity = quantity;\n\n    tempNode->next = new_node;\n    new_node->next = head;\n\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4624, "matched_exact": 0, "matched_approx": 340, "matched_human": 801, "matched_total": 5765, "suggestions_matched": 0, "suggestions_approx": 2, "suggestions_total": 2, "suggestions_with_funcs": 2}}
{"uuid": "21cb2508-2c4a-468d-a771-002ba7e0f211", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    if(head == NULL){\n\treturn EXIT_FAILURE;\n\t}\t\n    while(head != NULL){\n\t} \t\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4723, "matched_exact": 0, "matched_approx": 0, "matched_human": 78, "matched_total": 4801, "suggestions_matched": 0, "suggestions_approx": 0, "suggestions_total": 4, "suggestions_with_funcs": 4}}
{"uuid": "26a41023-c10e-41cc-b9e1-8103dc46f264", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n", "function": null, "extra_info": null}, {"label": "Human", "text": "#include <limits.h>\n", "function": null, "extra_info": null}, {"label": "Template", "text": "#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "   ", "function": "list_item_to_string", "extra_info": null}, {"label": "CodexApproximate", "text": " if(head == NULL)\n        return EXIT_FAILURE;\n\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": {"ts": "2022-04-11T20:18:58.280Z", "text": "if(head == NULL)\n        return EXIT_FAILURE;\n\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUCCESS;\n}", "distance": 0.012578616352201259}}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_print", "extra_info": null}, {"label": "CodexApproximate", "text": "int i = 1;\n    while (head != NULL) {\n        // char str[MAX_ITEM_PRINT_LEN] = {0};\n        // list_item_to_string(head, str);\n        printf(\"%d: %d * %s", "function": "list_print", "extra_info": {"ts": "2022-04-11T20:20:20.192Z", "text": "int i = 1;\n    while (head != NULL) {\n        char str[MAX_ITEM_PRINT_LEN] = {0};\n        list_item_to_string(head, str);\n        printf(\"%d: %s\\n\", i, str", "distance": 0.1032258064516129}}, {"label": "Human", "text": " @ $%.2f ea\\n\", i, head->quantity, head->item_name, head->price);\n        i++;\n        head = head->next;\n    }\n    return EXIT_SUCCESS;\n}\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "\n\n// add a new item to the list\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_add(node **head, int quantity, char *item_name, float price) {\n    node* cur;\n    for (cur = *head; cur; cur = cur->next) {} \n    node* new = (node*) malloc(sizeof(node));\n    new->quantity = quantity;\n    strcpy(new->item_name, item_name);\n    // new->item_name = item_name;\n    new->price = price;\n    new->next = NULL;\n    if (cur == NULL) {\n        *head = new;\n    }\n    else {\n        cur->next = new;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_add", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "node *item = malloc(sizeof(node));\n    if (item == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    item->item_name = item_name;\n    item->price = price;\n    item->quantity = quantity;", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-11T20:10:19.215Z", "text": "node *item = malloc(sizeof(node));\n    if (item == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    item->item_name = item_name;\n    item->price = price;\n    item->quantity = quantity;"}}, {"label": "Human", "text": "\n    item->next = NULL;\n\n    if (*head == NULL) {\n        *head = item;\n        return EXIT_SUCCESS;\n    }\n\n    node *cur = *head;\n    for (int i = 0; i < pos - 1; i++) {\n        if (cur->next == NULL) {\n            return EXIT_FAILURE;\n        }\n\n        cur = cur->next;\n    }\n    \n    item->next = cur->next;\n    cur->next = item;\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "if (*head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    node *cur = *head;\n    for (unsigned int i = 0; i < pos - 1; i++) {\n        if (cur->next == NULL) {\n            return EX", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-11T20:22:51.139Z", "text": "if (*head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    node *cur = *head;\n    for (unsigned int i = 0; i < pos - 1; i++) {\n        if (cur->next == NULL) {\n            return EX"}}, {"label": "Human", "text": "IT_FAILURE;\n        }\n\n        cur = cur->next;\n    }\n\n    cur->item_name = item_name;\n    cur->price = price;\n    cur->quantity = quantity;\n    return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if (*head == NULL)\n        return EXIT_FAILURE;\n\n    node *cur = *head;\n    if (cur == NULL)\n        return EXIT_FAILURE;\n\n    if (pos == 0) {\n        *head = cur->next;\n       ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": " free(cur);\n        return EXIT_SUCCESS;\n    }\n\n    for (int i = 0; i < pos - 1; i++) {\n        if (cur->next == NULL)\n            return EXIT_FAILURE;\n        cur = cur->next;", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-11T20:23:49.843Z", "text": " free(cur);\n        return EXIT_SUCCESS;\n    }\n\n    for (int i = 0; i < pos - 1; i++) {\n        if (cur->next == NULL)\n            return EXIT_FAILURE;\n        cur = cur->next;"}}, {"label": "Human", "text": "\n    }\n    \n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    if (*head == NULL)\n        return EXIT_FAILURE;\n\n    node *cur = *head;\n    if (pos1 == pos2)\n        return EXIT_SUCCESS;\n\n    if (pos1 < pos2) {\n        for (int i = 0; i < pos1 - 1; i++) {\n            if (cur->next == NULL)\n                return EXIT_FAILURE;\n            cur = cur->next;\n        }\n        for (int i = 0; i < pos2 - pos1 - 1; i", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Codex", "text": "++) {\n            if (cur->next == NULL)\n                return EXIT_FAILURE;\n            cur = cur->next;\n        }\n    } else {\n        for (int i = 0; i < pos2 - 1; i++) {\n            if (cur->", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-11T20:27:21.316Z", "text": "++) {\n            if (cur->next == NULL)\n                return EXIT_FAILURE;\n            cur = cur->next;\n        }\n    } else {\n        for (int i = 0; i < pos2 - 1; i++) {\n            if (cur->"}}, {"label": "Human", "text": "next == NULL)", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "\n                return EXIT_FAILURE;\n            cur = cur->next;\n        }\n        for (int i = 0; i < pos1 - pos2 - 1; i++) {\n            if (cur->next == NULL)\n              ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-11T20:23:37.478Z", "text": "\n    if (*head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    node *cur = *head;\n    for (unsigned int i = 0; i < pos - 1; i++) {\n        if (cur->next == NULL) {\n           ", "distance": 0.3651685393258427}}, {"label": "Human", "text": "  return EXIT_FA", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Codex", "text": "ILURE;\n            cur = cur->next;\n        }\n    }\n\n    node *temp = cur->next;\n    cur->next = temp->next;\n    temp->next = cur;\n    if (pos2 == 0) {\n        *head = temp;\n", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-11T20:27:26.433Z", "text": "ILURE;\n            cur = cur->next;\n        }\n    }\n\n    node *temp = cur->next;\n    cur->next = temp->next;\n    temp->next = cur;\n    if (pos2 == 0) {\n        *head = temp;\n"}}, {"label": "Human", "text": "    } else {\n        node *prev = *head;\n        for (int i = 0; i < pos2 - 1; i++)", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": " {\n            if (prev->next == NULL)\n                return EXIT_FAILURE;\n            prev = prev->next;\n        }\n        prev->next = temp;\n    }\n\n    return EXIT_SUCCESS;\n}", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-11T20:12:28.950Z", "text": "if (cur->next == NULL) {\n            return EXIT_FAILURE;\n        }\n\n        cur = cur->next;\n    }\n\n    item->next = cur->next;\n    cur->next = item;\n    return EXIT_SUCCESS;\n}", "distance": 0.4124293785310734}}, {"label": "Human", "text": "\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "\n// remove the first item with the given item_name\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_remove_item_with_name(node **head, char *item_name) {\n    int pos = 0;\n    for (node* cur = *head; cur; cur = cur->next) {\n        if (strcmp(cur->item_name, item_name) == 0) {\n            list_remove_item_at_pos(head, pos);\n            return EXIT_SUCCESS;\n        }\n        ++pos;\n    }\n", "function": "list_remove_item_with_name", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_with_name", "extra_info": null}, {"label": "Template", "text": "// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    FILE* fptr = fopen(filename, \"w\");\n    if (fptr == NULL) {\n        return EXIT_FAILURE;\n    }\n    for (; head; head = head->next) {\n        fprintf(fptr, \"%s,%f,%d\",head->item_name, head->price, head->quantity);\n    }\n    fclose(fptr);\n    return EXIT_SUCCESS;\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    FILE* fptr = fopen(filename, \"r\");\n    if (fptr == NULL) {\n        return EXIT_FAILURE;\n    }\n    int* quantity;\n    char* item_name;\n    float* price;\n    while (fscanf(fptr, \"%s,%f,%d\\n\", item_name, price, quantity) > 0) {\n        list_add(head, *quantity,item_name, *price);\n    }\n    fclose(fptr);\n    return EXIT_SUCCESS;\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "    int dup = 1;\n    while (dup) {\n        dup = 0;\n        for (node* cur = *head; cur; cur = cur->next) {\n            char* name1 = cur->item_name;\n            int pos;\n            for (node* cur2 = cur->next; cur2; cur2 = cur2->next) {\n                pos = 1;\n                if (cur2->item_name == name1) {\n                    dup = 1;\n                    cur->quantity += cur2->quantity;\n                    list_remove_item_at_pos(&cur, pos);\n                }\n                ++pos;\n            }\n        }\n    }\n    return EXIT_SUCCESS;\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Codex", "text": "    // TODO: Implement this ", "function": "list_find_highest_price_item_position", "extra_info": {"ts": "2022-04-11T20:17:20.197Z", "text": "    // TODO: Implement this "}}, {"label": "Human", "text": "function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    int hightest_price = INT_MIN;\n    for (node* cur = head; cur; cur = cur->next) {\n        if (cur->price > hightest_price) {\n            cur->price = hightest_price;\n        }\n        ++*pos;\n    }\n    return EXIT_SUCCESS;\n}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_cost_sum(node *head, float *total)\n{\n   ", "function": "list_cost_sum", "extra_info": null}, {"label": "Codex", "text": " // TODO: Implement this ", "function": "list_cost_sum", "extra_info": {"ts": "2022-04-11T20:21:03.444Z", "text": " // TODO: Implement this "}}, {"label": "Human", "text": "function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    *total = 0;\n    for (node* cur = head; cur; cur = cur->next) {\n        *total += cur->price * cur->quantity;\n    }\n    return EXIT_SUCCESS;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 3655, "matched_exact": 965, "matched_approx": 669, "matched_human": 4093, "matched_total": 9382, "suggestions_matched": 7, "suggestions_approx": 4, "suggestions_total": 16, "suggestions_with_funcs": 9}}
{"uuid": "3533dacf-349b-4581-bc32-6b9f015199c1", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    // if head is not NULL", "function": "list_item_to_string", "extra_info": null}, {"label": "CodexApproximate", "text": ", set str to contents of the node\n    if (head) {\n        sprintf(str, \"%d * %s @ $%0.2f ea\", head->quantity, head->item_name, head->price);\n        return EXIT_SUCCESS;\n    } else {", "function": "list_item_to_string", "extra_info": {"ts": "2022-04-08T00:13:42.963Z", "text": "\n    while(head) {\n        // print the item\n        printf(\"%d: %d * %s @ $%0.2f ea\\n\", head->position, head->quantity, head->item_name, head->price);\n        // advance to the next", "distance": 0.4945054945054945}}, {"label": "Human", "text": "\n        return EXIT_FAILURE;\n    }\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    char str[100];\n    if(head == NULL) {\n        return EXIT_FAILURE;\n    }\n    // print each item in the list as a string\n    node* curr = head;\n    int pos = 1;\n    while(curr != NULL) {\n        list_item_to_string(curr, str);\n        printf(\"%d: %s\\n\", pos, str);\n        curr = curr->next;\n        pos ++;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    // if pos is 1 assign head to new node\n    if(pos == 1) {\n        ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "node *new_node = malloc(sizeof(node));\n        new_node->item_name = malloc(sizeof(item_name));\n        strcpy(new_node->item_name, item_name);\n        new_node->price = price;\n", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-08T00:04:10.990Z", "text": "node *new_node = malloc(sizeof(node));\n        new_node->item_name = malloc(sizeof(item_name));\n        strcpy(new_node->item_name, item_name);\n        new_node->price = price;\n"}}, {"label": "CodexApproximate", "text": "        new_node->quantity = quantity;\n        new_node->next = *head;\n        *head = new_node;\n        return EXIT_SUCCESS;\n    }\n\n    // decrement pos until pos = 1\n    node *current = *head;\n  ", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-08T00:04:26.773Z", "text": "    new_node->quantity = quantity;\n        new_node->next = *head;\n        *head = new_node;\n    }\n    // if pos is 2, assign head->next to new node\n    else if (pos == 2) {\n        node *current =", "distance": 0.38578680203045684}}, {"label": "Human", "text": "  while (pos > 2 && current != NULL) {\n        current = current->next;\n        pos--;\n    }\n\n    if(current == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    // create node\n    node *new_node = malloc(sizeof(node));", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "\n    new_node->item_name = malloc(sizeof(item_name));\n    strcpy(new_node->item_name, item_name);\n    new_node->price = price;\n    new_node->quantity = quantity;\n    new_node", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-08T00:06:17.281Z", "text": "\n    new_node->item_name = malloc(sizeof(item_name));\n    strcpy(new_node->item_name, item_name);\n    new_node->price = price;\n    new_node->quantity = quantity;\n    new_node"}}, {"label": "Human", "text": "->next = current->next;\n    current->next = new_node;\n\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if(*head == NULL) {\n        return EXIT_FAILURE;\n    }\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "    node* curr = *head;\n    for(int i = 1; i < pos; i++) {\n        curr = curr->next;\n        if(curr == NULL) {\n            return EXIT_FAILURE;\n        }\n    ", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-08T22:02:25.899Z", "text": "\n    for(int i = 1; i < pos1; i++) {\n        prev1 = curr1;\n        curr1 = curr1->next;\n        if(curr1 == NULL) {\n            return EXIT_FAILURE;\n        }\n", "distance": 0.325}}, {"label": "Human", "text": "}\n\n    curr->item_name = item_name;\n    curr->price = price;\n    curr->quantity = quantity;\n    return EXIT_SUCCESS;\n}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n// remove the item at position *pos*\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_remove_item_at_pos(node **head, int pos) {\n    if(head == NULL) {\n        return EXIT_FAILURE;\n    }\n    if(pos == 1) {\n        *head = (*head)->next;\n        return EXIT_SUCCESS;\n    }\n    node* curr = *head;\n    ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "for(int i = 1; i < pos - 1; i++) {\n        curr = curr->next;\n        if(curr == NULL) {\n            return EXIT_FAILURE;\n        }\n    }\n    if(curr->next == NULL)", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-09T23:26:49.860Z", "text": "for(int i = 1; i < pos - 1; i++) {\n        curr = curr->next;\n        if(curr == NULL) {\n            return EXIT_FAILURE;\n        }\n    }\n    if(curr->next == NULL)"}}, {"label": "Human", "text": " {\n        return EXIT_FAILURE;\n    }\n    node* next = curr->next;\n    curr->next = next->next;\n    free(next);\n    return EXIT_SUCCESS;\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    if(*head == NULL) {\n        return EXIT_FAILURE;\n    }\n    node* prev1 = NULL;\n    node* prev2 = NULL;\n    node* curr1 = *head;\n    node* curr2 = *head;\n\n    // find the two nodes", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Codex", "text": "\n    while(curr1 != NULL && pos1 > 1) {\n        prev1 = curr1;\n        curr1 = curr1->next;\n        pos1--;\n    }\n    if(curr1 == NULL) {\n        return EXIT_FA", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-09T23:42:21.769Z", "text": "\n    while(curr1 != NULL && pos1 > 1) {\n        prev1 = curr1;\n        curr1 = curr1->next;\n        pos1--;\n    }\n    if(curr1 == NULL) {\n        return EXIT_FA"}}, {"label": "Human", "text": "ILURE;\n    }\n    while(curr2 != NU", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "LL && pos2 > 1) {\n        prev2 = curr2;\n        curr2 = curr2->next;\n        pos2--;\n    }\n    if(curr2 == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    // swap ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-09T23:26:07.991Z", "text": "node* curr = *head;\n    for(int i = 1; i < pos; i++) {\n        curr = curr->next;\n        if(curr == NULL) {\n            return EXIT_FAILURE;\n        }\n    }\n    if", "distance": 0.47560975609756095}}, {"label": "Human", "text": "nodes\n    if(prev1 != NULL) {\n        prev1->next = curr2;\n    } else {\n        *head = curr2;\n    }\n    if(prev2 !=", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Codex", "text": " NULL) {\n        prev2->next = curr1;\n    } else {\n        *head = curr1;\n    }\n    node* temp = curr1->next;\n    curr1->next = curr2->next;\n    curr2->next", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-09T23:42:30.473Z", "text": " NULL) {\n        prev2->next = curr1;\n    } else {\n        *head = curr1;\n    }\n    node* temp = curr1->next;\n    curr1->next = curr2->next;\n    curr2->next"}}, {"label": "Human", "text": " = temp;\n\n    return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_find_highest_price_item_position(node *head, int *pos){\n    if(head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    int maxPri = head->price;\n    *pos = 1;\n    node* curr = head;\n    int currPos = 1;\n    while(curr != NULL) {\n        if(curr->price > maxPri) {\n            *pos = currPos;\n            maxPri = curr->price;\n        }\n        curr = curr->next;\n        currPos ++;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_cost_sum(node *head, float *t", "function": "list_cost_sum", "extra_info": null}, {"label": "CodexApproximate", "text": "otal) {\n    if(head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    *total = 0;\n    node* curr = head;\n    while(curr != NULL) {\n        *total += curr->p", "function": "list_cost_sum", "extra_info": {"ts": "2022-04-08T22:02:51.539Z", "text": "\n        if(curr1 == NULL) {\n            return EXIT_FAILURE;\n        }\n    }\n    item1 = curr1;\n\n    for(int i = 1; i < pos2; i++) {\n        prev2 = curr2;\n", "distance": 0.49044585987261147}}, {"label": "Human", "text": "rice * curr->quantity;\n        curr = curr->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_save(node *head, char *filename) {\n    if(head == NULL) {\n        return EXIT_FAILURE;\n    }\n    FILE* f = fopen(filename, \"w\");\n    if(f == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    node* curr = head;\n    while(curr != NULL) {\n        fprintf(f, \"%s,%0.2f,%d\\n\", curr->item_name, curr->price, curr->quantity);\n        curr = curr->next;\n    }\n\n    fclose(f);\n    return EXIT_SUCCESS;\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "\n\n// helper function\n", "function": null, "extra_info": null}, {"label": "Human", "text": "char* memRealloc(char* buffer, int oldSize, int newSize) {\n    char* newBuffer = malloc(newSize);\n    for(int i = 0; i < oldSize; i++)\n        newBuffer[i] = buffer[i];\n    return newBuffer;\n}\n", "function": "memRealloc", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_load(node **head, char *filename) {\n    *head = NULL; \n\n    FILE* f = fopen(filename, \"r\");\n    if(f == NULL) {\n        return EXIT_FAILURE;\n    }\n    \n    int bufSize = 5;\n    int bytesRead = 0;\n\n    char* buf = malloc(bufSize);\n    int res = fread(buf, 1, bufSize, f);\n    bytesRead += res;\n\n    while(res > 0) {\n        if(bytesRead == bufSize) {\n            int oldSize = bufSize;\n            bufSize *= 2;\n            buf = memRealloc(buf, oldSize, bufSize);\n        }\n\n        res = fread(buf+bytesRead, 1, bufSize-bytesRead, f);\n        bytesRead += res;\n    }   \n\n    int state = 0;\n    int start = 0;\n    int end = 0;\n    int strSize = 20;\n    int pos = 1;\n    char* str = malloc(strSize);\n    char* item_name;\n    float price;\n    int quantity = 0;\n    for(int i = 0; i < bytesRead; i++) {\n        if(buf[i] == ',' || buf[i] == '\\n') {\n            end = i;\n            int newSize = end-start;\n\n            if(i + 1 == bytesRead) newSize += 1;\n\n            str = memRealloc(str, strSize, newSize);\n            memmove(str, buf+start, newSize);\n            strSize = newSize;\n            start = end+1;\n\n            if(state == 0) {\n                item_name = str;\n                state = 1;\n            } else if(state == 1) {\n                price = atof(str);\n                state = 2;\n            } else if(state == 2) {\n                quantity = atoi(str);\n                list_add_item_at_pos(head, item_name, price, quantity, pos);\n                pos ++ ; \n                state = 0;\n            }\n        }\n    }\n\n    fclose(f);\n    free(str);\n    free(buf);\n    return EXIT_SUCCESS;\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "\n\n\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_deduplicate(node **head) {\n    if(*head == NULL) {\n        return EXIT_FAILURE;\n    }\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "    node* curr = (*head)->next;\n    node* prev = *head", "function": "list_deduplicate", "extra_info": null}, {"label": "CodexApproximate", "text": ";\n    int range = 2;\n    while(curr != NULL) {\n        node* itr = *head;\n        int i;\n        for(i = 1; i < range; i++) {\n            if(0 == strcmp(", "function": "list_deduplicate", "extra_info": {"ts": "2022-04-09T23:29:09.144Z", "text": "1 = curr1->next;\n        if(curr1 == NULL) {\n            return EXIT_FAILURE;\n        }\n    }\n    for(int i = 1; i < pos2; i++) {\n        prev2 = curr2;\n", "distance": 0.49673202614379086}}, {"label": "Human", "text": "itr->item_name, curr->item_name)){\n                int q1 = itr->quantity;\n                int q2 = curr->quantity;\n                int newQ = q1+q2;\n                list_update_item_at_pos(head, itr->item_name, itr->price, newQ, i);\n                list_remove_item_at_pos(head, range);\n                break;\n            }\n            itr = itr->next;\n        }\n        if(i == range) {\n            curr = curr->next;\n            range ++;\n        } else {\n            curr = prev->next;\n        }\n        \n    }\n\n    return EXIT_SUCCESS;\n}\n", "function": "list_deduplicate", "extra_info": null}], "matchdata": {"matched_template": 3025, "matched_exact": 831, "matched_approx": 1013, "matched_human": 5181, "matched_total": 10050, "suggestions_matched": 5, "suggestions_approx": 6, "suggestions_total": 24, "suggestions_with_funcs": 0}}
{"uuid": "36deba30-9345-480d-8221-387f5192f83d", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n", "function": "list_init", "extra_info": null}, {"label": "Human", "text": "   *head = NULL;\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    if(head == NULL)\n    {\n        //printf(\"head is NULL\\n\");\n        return EXIT_FAILURE;\n    }\n    sprintf(str, \"%d * %s @ $%0.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    int i = 1;\n    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *curr = head;\n    char str[MAX_ITEM_PRINT_LEN];\n    wh", "function": "list_print", "extra_info": null}, {"label": "CodexApproximate", "text": "ile (curr != NULL) {\n        list_item_to_string(curr, str);\n        printf(\"%d: %s\\n\", i, str);\n        i++;\n        curr = curr->next;\n    }\n    return EXIT_SUCC", "function": "list_print", "extra_info": {"ts": "2022-05-02T00:53:50.383Z", "text": "(\"%d: %s\\n\", i, str);\n        }\n        else {\n            printf(\"%d: %s\\n\", i, str);\n        }\n        i++;\n        curr = curr->next;\n    }\n    return EXIT_SUCC", "distance": 0.3619631901840491}}, {"label": "Human", "text": "ESS;\n\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "\n\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    node *prev = *head;\n    if (pos == 1){\n        ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "node *new_node = malloc(sizeof(node));\n        new_node->item_name = item_name;\n        new_node->price = price;\n        new_node->quantity = quantity;\n        new_node->next = *head;\n        *he", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-03T01:09:38.010Z", "text": "node *new_node = malloc(sizeof(node));\n        new_node->item_name = item_name;\n        new_node->price = price;\n        new_node->quantity = quantity;\n        new_node->prev = NULL;\n        new_", "distance": 0.06666666666666667}}, {"label": "Human", "text": "ad = new_node;\n        return EXIT_SUCCESS;\n    }\n    while (prev != NULL && pos != 2){\n        pos--;\n        prev = prev->next;\n    }\n    if (prev == NULL){\n        return EXIT_FAILURE;\n    }\n    ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "node *new_node = malloc(sizeof(node));\n    new_node->item_name = item_name;\n    new_node->price = price;\n    new_node->quantity = quantity;\n    new_node->next = prev->next;\n  ", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-03T01:17:04.778Z", "text": "node *new_node = malloc(sizeof(node));\n    new_node->item_name = item_name;\n    new_node->price = price;\n    new_node->quantity = quantity;\n    prev->next = new_node;\n    new_", "distance": 0.12571428571428572}}, {"label": "Human", "text": "  prev->next = new_node;\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "node *curr = *head;\n    if (pos == 1){\n        curr->item_name = item_name;\n        curr->price = price;\n        curr->quantity = quantity;\n        return EXIT_SUCCESS;\n    }\n   ", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-03T01:41:46.910Z", "text": "node *curr = *head;\n    if (pos == 1){\n        curr->item_name = item_name;\n        curr->price = price;\n        curr->quantity = quantity;\n        return EXIT_SUCCESS;\n    }\n   "}}, {"label": "Human", "text": " while (curr != NULL && pos != 1){\n        curr = curr->next;\n    ", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "    pos--;\n    }\n    if (curr == NULL){\n        return EXIT_FAILURE;\n    }\n    curr->item_name = item_name;\n    curr->price = price;\n    curr->quantity = quantity;\n    ret", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-03T01:09:55.886Z", "text": " = curr->next;\n    }\n    if (curr == NULL){\n        return EXIT_FAILURE;\n    }\n    else {\n        node *new_node = malloc(sizeof(node));\n        new_node->item_name = item", "distance": 0.49707602339181284}}, {"label": "Human", "text": "urn EXIT_SUCCESS;\n}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n\n\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_remove_item_at_pos(node **head, int pos)", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": " {\n    // TODO: Implement this ", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-05-02T02:19:23.256Z", "text": " {\n    // TODO: Implement this "}}, {"label": "Human", "text": "\n    ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "// return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    node *temp, *prev;\n    if (pos == 1){\n        temp = *head;\n        *head = temp->next;\n        temp = NULL;\n        return EX", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-05-02T02:19:35.017Z", "text": "// return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    FILE *fp;\n    fp = fopen(filename, \"w\");\n    if (fp == NULL) {\n        printf(\"Error opening file!\\n\");\n        return EXIT_FA", "distance": 0.478494623655914}}, {"label": "Human", "text": "IT_SUCCESS;\n    ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "}else if(pos > 1){\n        temp = *head;\n        prev = NULL;\n        while (pos>1){\n            if (temp == NULL){\n                return EXIT_FAILURE;\n            }\n            pos--;\n            prev = temp;\n           ", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-05-02T00:30:56.176Z", "text": "}else if(pos > 1){\n        temp = *head;\n        prev = NULL;\n        while (pos>1){\n            if (temp == NULL){\n                return EXIT_FAILURE;\n            }\n            pos--;\n            prev = temp;\n           "}}, {"label": "Human", "text": " temp = temp->next;\n        }\n        prev->next = temp->next;\n        temp = NULL;\n        return EXIT_SUCCESS;\n    }\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    // TODO: Implement", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Codex", "text": " this ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-01T05:42:39.686Z", "text": " this "}}, {"label": "Human", "text": "\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "    if (pos1 == pos2){\n        return EXIT_SUCCESS;\n    }\n    node *curr1 = *head;\n    node *curr2 = *head;\n    node *prev1 = NULL;\n    node *prev2 = NULL;\n    wh", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-03T02:19:46.012Z", "text": "if (pos1 < 2 || pos2 < 2){\n        return EXIT_FAILURE;\n    }\n    node *prev1 = *head;\n    node *prev2 = *head;\n    while (pos1 != 2){\n        prev1 = prev1->next", "distance": 0.3765432098765432}}, {"label": "Human", "text": "ile(curr1 != NULL && curr2 != NULL){\n        if (pos1 == 1){\n            break;\n        }\n        prev1 = curr1;\n        curr1 =", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Codex", "text": " curr1->next;\n        if (pos2 == 1){\n            break;\n        }\n        prev2 = curr2;\n        curr2 = curr2->next;\n        pos1--;\n        pos2--;\n    }\n    if (cur", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-03T02:36:19.053Z", "text": " curr1->next;\n        if (pos2 == 1){\n            break;\n        }\n        prev2 = curr2;\n        curr2 = curr2->next;\n        pos1--;\n        pos2--;\n    }\n    if (cur"}}, {"label": "Codex", "text": "r1 == NULL || curr2 == NULL){\n        return EXIT_FAILURE;\n    }\n    if (prev1 != NULL){\n        prev1->next = curr2;\n    }\n    else{\n        *head = curr2;\n    }", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-03T02:36:26.832Z", "text": "r1 == NULL || curr2 == NULL){\n        return EXIT_FAILURE;\n    }\n    if (prev1 != NULL){\n        prev1->next = curr2;\n    }\n    else{\n        *head = curr2;\n    }"}}, {"label": "Codex", "text": "\n    if (prev2 != NULL){\n        prev2->next = curr1;\n    }\n    else{\n        *head = curr1;\n    }\n    node *tmp = curr1->next;\n    curr1->next = curr2->", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-03T02:36:43.941Z", "text": "\n    if (prev2 != NULL){\n        prev2->next = curr1;\n    }\n    else{\n        *head = curr1;\n    }\n    node *tmp = curr1->next;\n    curr1->next = curr2->"}}, {"label": "Human", "text": "next;\n    curr2->next = tmp;\n    return EXIT_SUCCESS;\n}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "\n// calculate the total cost of the list (sum of all prices * quantity)\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_cost", "function": "list_cost_sum", "extra_info": null}, {"label": "CodexApproximate", "text": "_sum(node *head, float *total){\n    // TODO: Implement this\n ", "function": "list_cost_sum", "extra_info": {"ts": "2022-05-01T22:45:17.569Z", "text": "node **head, unsigned int pos) {\n    // TODO: Implement this ", "distance": 0.36065573770491804}}, {"label": "Human", "text": "   ", "function": "list_cost_sum", "extra_info": null}, {"label": "Codex", "text": "// return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    node *curr = head;\n    float sum = 0;\n    while (curr != NULL){\n        sum += curr->price * curr->quantity;\n        curr = cur", "function": "list_cost_sum", "extra_info": {"ts": "2022-05-03T02:00:28.168Z", "text": "// return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    node *curr = head;\n    float sum = 0;\n    while (curr != NULL){\n        sum += curr->price * curr->quantity;\n        curr = cur"}}, {"label": "Human", "text": "r->next;\n    }\n    *total = sum;\n    return EXIT_SUCCESS;\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_find_highest_price_item_position(nod", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "CodexApproximate", "text": "e *head, int *pos) {\n    // TODO: Implement this", "function": "list_find_highest_price_item_position", "extra_info": {"ts": "2022-05-01T22:49:19.244Z", "text": ", char *filename) {\n    // TODO: Implement this ", "distance": 0.3125}}, {"label": "Human", "text": "\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    *pos = 1;\n    int i = 1;\n    node *curr = head;\n    float highest = curr->price;\n    while (curr", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Codex", "text": " != NULL) {\n        if (curr->price > highest) {\n            highest = curr->price;\n            *pos = i;\n        }\n        i++;\n        curr = curr->next;\n    }\n    return EXIT_SUCCESS;", "function": "list_find_highest_price_item_position", "extra_info": {"ts": "2022-05-03T02:43:46.965Z", "text": " != NULL) {\n        if (curr->price > highest) {\n            highest = curr->price;\n            *pos = i;\n        }\n        i++;\n        curr = curr->next;\n    }\n    return EXIT_SUCCESS;"}}, {"label": "Human", "text": "\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "\n\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// item_name, price, quantity\\n\n", "function": null, "extra_info": null}, {"label": "Codex", "text": "// one item per ", "function": null, "extra_info": {"ts": "2022-05-02T02:19:51.975Z", "text": "// one item per "}}, {"label": "Human", "text": "line, separated by commas and new line at the end\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_save(node *head, char *filename)", "function": "list_save", "extra_info": null}, {"label": "Codex", "text": " {\n    // TODO: Implement this ", "function": "list_save", "extra_info": {"ts": "2022-05-02T02:59:46.698Z", "text": " {\n    // TODO: Implement this "}}, {"label": "Human", "text": "{\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    FILE *fp;\n    fp = fopen(filename, ", "function": "list_save", "extra_info": null}, {"label": "CodexApproximate", "text": "\"w\");\n    if (fp == NULL) {\n        printf(\"Error opening file!\\n\");\n        return EXIT_FAILURE;\n    }\n    node *curr = head;\n    while (curr != NULL) {\n        fprintf(fp, \"%s,%.2f,%d\\n\", cu", "function": "list_save", "extra_info": {"ts": "2022-05-02T05:54:19.099Z", "text": "\n    if(curr == NULL) {\n        printf(\"Error: list is empty.\\n\");\n        return EXIT_FAILURE;\n    }\n    if(str == NULL) {\n        printf(\"Error: output string is NULL.\\n\");\n        return EX", "distance": 0.4947916666666667}}, {"label": "Human", "text": "rr->item_name, curr->price, curr->quantity);\n        curr = curr->next;\n    }\n    fclose(fp);\n    return EXIT_SUCCESS;\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n\n// load the list from file filename\n// the file should be in the following format:\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "// item_name, price, quantity\\n\n", "function": "list_save", "extra_info": null}, {"label": "Codex", "text": "// one item per ", "function": "list_save", "extra_info": {"ts": "2022-05-02T02:19:54.436Z", "text": "// one item per "}}, {"label": "Human", "text": "line, separated by commas and new line at the end\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_load(node **head, char *filename)", "function": "list_load", "extra_info": null}, {"label": "Codex", "text": " {\n    // TODO: Implement this ", "function": "list_load", "extra_info": {"ts": "2022-05-02T02:59:48.760Z", "text": " {\n    // TODO: Implement this "}}, {"label": "Human", "text": "\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    int pos = 1;\n    while(*head !=NULL){\n        pos++;\n        *head = (*head)->next;\n    }\n    FILE *fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        return EXIT_FAILURE;\n    }\n    char *item_name = (", "function": "list_load", "extra_info": null}, {"label": "Codex", "text": "char ", "function": "list_load", "extra_info": {"ts": "2022-05-02T02:28:32.052Z", "text": "char "}}, {"label": "Human", "text": "*) malloc(sizeof(char)*256);\n    float price", "function": "list_load", "extra_info": null}, {"label": "CodexApproximate", "text": ";\n    int quantity;\n    while (fscanf(fp, \"%s,%f,%d\\n\", item_name, &price, &quantity)!= EOF){\n        list_add_item_at_pos(&(*head), item_name, price, quantity, ", "function": "list_load", "extra_info": {"ts": "2022-05-02T02:22:17.003Z", "text": "[100];\n    int quantity;\n    while (fscanf(fp, \"%s, %s, %d\", item_name, price, &quantity) != EOF) {\n        list_add(head, item_name, atof(price), quantity);\n   ", "distance": 0.2484472049689441}}, {"label": "Human", "text": "pos);\n        pos++;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}, {"label": "Human", "text": "\n// de-duplicate the list by combining items with the same name\n// by adding their quantities\n// The order of the returned list is undefined and may be in any ordder\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_deduplicate (node **h", "function": "list_deduplicate", "extra_info": null}, {"label": "CodexApproximate", "text": "ead) ", "function": "list_deduplicate", "extra_info": {"ts": "2022-05-01T05:45:32.668Z", "text": "each ", "distance": 0.4}}, {"label": "Human", "text": "{", "function": "list_deduplicate", "extra_info": null}, {"label": "Codex", "text": "\n    // TODO: Implement this ", "function": "list_deduplicate", "extra_info": {"ts": "2022-05-03T01:42:25.942Z", "text": "\n    // TODO: Implement this "}}, {"label": "Human", "text": "function\n    // return EXIT_SUCCESS or EXIT FAILURE when appropriate\n    // ", "function": "list_deduplicate", "extra_info": null}, {"label": "CodexApproximate", "text": "node *temp, *prev, *curr;\n    // prev = NULL;\n    // curr = *head;\n    // temp = curr->next;\n    // while(temp != NULL){\n    //     if(strcmp(curr->item_name,temp", "function": "list_deduplicate", "extra_info": {"ts": "2022-05-02T02:59:39.150Z", "text": "node *temp, *prev, *curr;\n    prev = NULL;\n    curr = *head;\n    temp = curr->next;\n    while(temp != NULL){\n        if(strcmp(curr->item_name,temp->item_name) ==", "distance": 0.18518518518518517}}, {"label": "Human", "text": "->item_name) == 0){\n    //         curr->quantity = curr->quantity + temp->quantity;\n    //         prev->next = temp->next;\n    //         free(temp);\n    //         temp = prev->next;\n    //     }else{\n    //         prev = curr;\n    //         curr = curr->next;\n    //         temp = curr->next;\n    //     }\n    // }\n    return EXIT_SUCCESS;\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_deduplicate", "extra_info": null}], "matchdata": {"matched_template": 3157, "matched_exact": 1421, "matched_approx": 1681, "matched_human": 2886, "matched_total": 9145, "suggestions_matched": 15, "suggestions_approx": 12, "suggestions_total": 63, "suggestions_with_funcs": 48}}
{"uuid": "3cff10bf-23d9-48f4-9f45-96a223a8e2de", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_item_to_string", "extra_info": null}, {"label": "Codex", "text": "if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUCC", "function": "list_item_to_string", "extra_info": {"ts": "2022-05-02T21:20:50.765Z", "text": "if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUCC"}}, {"label": "Human", "text": "ESS;\n}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "\n// print the entire list\n", "function": null, "extra_info": null}, {"label": "CodexApproximate", "text": "int list_print(node *head)\n{\n    // TODO: Implement this \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *temp = he", "function": "list_print", "extra_info": {"ts": "2022-05-02T21:22:10.897Z", "text": "\n// print the entire list\nint list_print_reverse(node *head)\n{\n    // TODO: Implement this \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    if (head == NULL) {\n        return EXIT_", "distance": 0.3469387755102041}}, {"label": "Human", "text": "ad;\n    while (temp != NULL) {\n        char item[MAX_ITEM_PRINT_LEN];\n        list_item_to_string(temp, item);\n        printf(\"%s\\n\", item);\n        temp = temp->next;\n    }\n    return EXIT_SUCCESS;\n}\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    \n// print the entire list\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_print_reverse(node *head)\n{\n    // TODO: Implement this \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    if (head == NULL) {\n        return EXIT_", "function": "list_print_reverse", "extra_info": null}, {"label": "Codex", "text": "FAILURE;\n    }\n    node *temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    while (temp != NULL) {\n        char item[MAX_ITEM_PRINT_LEN];\n", "function": "list_print_reverse", "extra_info": {"ts": "2022-05-02T21:22:14.989Z", "text": "FAILURE;\n    }\n    node *temp = head;\n    while (temp->next != NULL) {\n        temp = temp->next;\n    }\n    while (temp != NULL) {\n        char item[MAX_ITEM_PRINT_LEN];\n"}}, {"label": "Human", "text": "\n", "function": "list_print_reverse", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n", "function": "list_print_reverse", "extra_info": null}, {"label": "Template", "text": "// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print1", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *temp = head;\n    int pos = 1;\n    while (temp != NULL) {\n        char item[MAX_ITEM_PRINT_LEN];\n        list_item_to_string(temp, item);\n        printf(\"%d: %s\\n\", pos, item);\n        temp = temp->next;\n        pos++;\n    }\n    return EXIT_SUCCESS;\n}\n", "function": "list_print1", "extra_info": null}, {"label": "Human", "text": "\n\n// add a new item to the", "function": null, "extra_info": null}, {"label": "Codex", "text": " end of a list\n// If the list is empty, the new node should be the only node in the list.\n// If the list is not empty, the new node should be added to the end of the list.\n// This ", "function": null, "extra_info": {"ts": "2022-05-02T21:22:38.482Z", "text": " end of a list\n// If the list is empty, the new node should be the only node in the list.\n// If the list is not empty, the new node should be added to the end of the list.\n// This "}}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    if (pos == 0) {\n        node *temp = malloc(sizeof(node));\n        temp->prev = NULL;\n        temp->next = *head;\n        temp->item_name = item_name;\n        temp->price = price;\n        temp->quantity = quantity;\n        *head = temp;\n        return EXIT_SUCCESS;\n    }\n    node *temp = *head;\n    for (int i = 1; i < pos && temp != NULL; i++) {\n        temp = temp->next;\n    }\n    if (temp == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *next = temp->next;\n    node *new_item =", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": " malloc(sizeof(node));\n    new_item->item_name = item_name;\n    new_item->price = price;\n    new_item->quantity = quantity;\n    new_item->prev = temp;\n    new_item->next = next;", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-02T21:23:00.689Z", "text": " malloc(sizeof(node));\n    new_item->item_name = item_name;\n    new_item->price = price;\n    new_item->quantity = quantity;\n    new_item->prev = temp;\n    new_item->next = next;"}}, {"label": "Human", "text": "\n\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    if (pos == 0) {\n        node *temp = *head;\n        temp->item_name = item_name;\n        temp->price = price;\n        temp->quant", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-02T21:23:20.702Z", "text": "if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    if (pos == 0) {\n        node *temp = *head;\n        temp->item_name = item_name;\n        temp->price = price;\n        temp->quant"}}, {"label": "Human", "text": "ity = quantity;\n        return EXIT_SUCCESS;", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "\n    }\n    node *temp = *head;\n    for (int i = 1; i < pos && temp != NULL; i++) {\n        temp = temp->next;\n    }\n    if (temp == NULL) {\n        return EXIT_FAILURE;\n", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-02T21:23:41.860Z", "text": "\n    }\n    node *temp = *head;\n    for (int i = 1; i < pos && temp != NULL; i++) {\n        temp = temp->next;\n    }\n    if (temp == NULL) {\n        return EXIT_FAILURE;\n"}}, {"label": "Human", "text": "    }\n    temp->item_name = item_name;\n    temp->price = price;\n    temp->quantity = quantity;\n    return EXIT_SUCCESS;\n}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n// delete the item at position\n", "function": null, "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    if (pos == 0) {\n        node *temp = *head;\n        *head = temp->next;\n        free(temp);\n        return EXIT_SUCCESS;\n\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    \n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    \n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4696, "matched_exact": 1045, "matched_approx": 196, "matched_human": 1769, "matched_total": 7706, "suggestions_matched": 6, "suggestions_approx": 1, "suggestions_total": 9, "suggestions_with_funcs": 3}}
{"uuid": "514e6c1d-f935-474d-899e-96e27d5babd3", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    // see the following for the format you need to implement:\n\n    // was fighting the language model whenever I was trying\n    // to do anything and I ended up giving up, because whenever\n    // I would start with an idea, it would suggest something that \n    // looked good at first sight, I would add it to my own code\n    // and then I would spend time debugging some of its code rather\n    // than develop my ideas\n\n    // for the other functions where it gave me the answer straight\n    // up and it just worked, I felt like I just cheated and got\n    // someone else to do the work for me\n\n    // I ended up not having too much time to finish and the couple\n    // hours I spent on this was mostly just fighting with the robot\n    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    else {}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    node * ptr = head;\n    int pos = 1;\n    char * str = ", "function": "list_print", "extra_info": null}, {"label": "CodexApproximate", "text": "malloc(MAX_ITEM_PRINT_LEN);\n    while(ptr->next != NULL){\n        list_item_to_string(ptr, str);\n        printf(\"%d: %s\\n\", pos, str);\n        ptr = ptr->next;\n      ", "function": "list_print", "extra_info": {"ts": "2022-04-13T02:35:38.020Z", "text": "malloc(MAX_ITEM_PRINT_LEN);\n        pos++;\n        list_item_to_string(ptr, str);\n        printf(\"%d: %s\\n\", pos, str);\n        ptr = ptr->next;\n    }\n    return EXIT", "distance": 0.2289156626506024}}, {"label": "Human", "text": "  pos++;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    // It did it all by itself, I didn't even have to do anything for this part\n    // cool I guess...\n    ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "// TODO: Implement this ", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-26T23:50:17.796Z", "text": "// TODO: Implement this "}}, {"label": "Human", "text": "\n    ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "node * new_node = malloc(sizeof(node));\n    new_node->item_name = item_name;\n    new_node->price = price;\n    new_node->quantity = quantity;\n    if (*head == NULL) {\n        new_node", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-26T23:59:33.158Z", "text": "node * new_node = malloc(sizeof(node));\n    new_node->item_name = item_name;\n    new_node->price = price;\n    new_node->quantity = quantity;\n    if (*head == NULL) {\n        new_node"}}, {"label": "Human", "text": "->next = NULL;\n    } else {\n        node * ptr = *head;\n        for (int i = 0; i < pos - 2; i++) {\n            if (ptr->next == NULL) {\n                return EXIT_FAILURE;\n            }\n            ptr = ptr->next;\n        }\n        new_node->next = ptr->next;\n        ptr->next = new_node;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4429, "matched_exact": 206, "matched_approx": 166, "matched_human": 1340, "matched_total": 6141, "suggestions_matched": 2, "suggestions_approx": 1, "suggestions_total": 14, "suggestions_with_funcs": 12}}
{"uuid": "6c026517-fcff-496b-a8d2-3b99e3714fa4", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n", "function": "list_init", "extra_info": null}, {"label": "Human", "text": "    // \n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "\n    // load list from filename\n    // add items to the end of the list\n\n    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "\n// free the list\n// free each node in the list\n// free the head node\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_free(node *head)\n{\n    // ", "function": "list_free", "extra_info": null}, {"label": "Codex", "text": "TODO: Implement this ", "function": "list_free", "extra_info": {"ts": "2022-04-12T15:55:10.419Z", "text": "TODO: Implement this "}}, {"label": "Human", "text": "\n\n", "function": "list_free", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_free", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "    // combine items in the list with the same name by adding their quantities\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// deallocates the list, including all allocated memory\n// ", "function": null, "extra_info": null}, {"label": "Codex", "text": "This ", "function": null, "extra_info": {"ts": "2022-04-26T18:00:06.804Z", "text": "This "}}, {"label": "Human", "text": "\n\n    return EXIT_FAILURE;\n}\n\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int main() {\n    // print Hello World! to stdout\n    printf(\"Hello World!\\n\");\n    return 0;\n}\n", "function": "main", "extra_info": null}, {"label": "Human", "text": "\n}\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4723, "matched_exact": 26, "matched_approx": 0, "matched_human": 481, "matched_total": 5230, "suggestions_matched": 2, "suggestions_approx": 0, "suggestions_total": 4, "suggestions_with_funcs": 2}}
{"uuid": "7193a853-f8dd-423a-90be-39d0023d598e", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    // Print an item to the specified format\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    node* curr_node = head;\n    int curr_pos = 1;\n    while (curr_node != NULL) {\n        char item_str[MAX_ITEM_PRINT_", "function": "list_print", "extra_info": null}, {"label": "CodexApproximate", "text": "LEN];\n        list_item_to_string(curr_node, item_str);\n        printf(\"%d: %s\\n\", curr_pos, item_str);\n        curr_pos++;\n        curr_node = curr", "function": "list_print", "extra_info": {"ts": "2022-04-18T02:23:41.044Z", "text": "%s\\n\", curr_pos, list_item_to_string(curr_node, str));\n        curr_node = curr_node->next;\n        curr_pos++;\n    }\n    return EXIT_SUCCESS;\n}\n\n//", "distance": 0.49324324324324326}}, {"label": "Human", "text": "_node->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    unsigned int curr_pos = 1;\n    node* curr_node = *head;\n    node* prev_node = NULL;\n\n    // Iterating through the list\n    while (curr_node != NU", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "LL && curr_pos < pos)\n    {\n        prev_node = curr_node;\n        curr_node = curr_node->next;\n        curr_pos++;\n    }\n\n    // Create a new node\n", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-18T02:23:43.144Z", "text": "%s\\n\", curr_pos, list_item_to_string(curr_node, str));\n        curr_node = curr_node->next;\n        curr_pos++;\n    }\n    return EXIT_SUCCESS;\n}\n\n//", "distance": 0.44594594594594594}}, {"label": "Human", "text": "    node *item_node = (node *)malloc(sizeof(node));\n\n    if (item_node == NULL)\n    {\n        printf(\"ERROR: malloc failed\\n\");\n        return EXIT_FAILURE;\n    }\n\n    item_node->item_name = item_name;\n    item_node->price = price;\n    item_node->quantity = quantity;\n    item_node->next = curr_node;\n\n    // Add new node to the list\n    if (prev_node == NULL) {\n        *head = item_nod", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "e;\n    } else {\n        prev_node->next = item_node;\n    }\n    item_node->next = curr", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-18T03:11:04.155Z", "text": "\n    } else {\n        prev_node->next = curr_node2;\n    }\n\n    return EXIT_SUCCESS;\n}", "distance": 0.3411764705882353}}, {"label": "Human", "text": "_node;\n\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "// Iterate to the correct position\n    unsigned int curr_pos = 1;\n    node* curr_node = *head;\n    while (curr_node != NULL && curr_pos < pos)\n    {\n        curr_node = curr_node", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-18T02:53:11.205Z", "text": "// Iterate to the correct position\n    unsigned int curr_pos = 1;\n    node* curr_node = *head;\n    node* prev_node = NULL;\n    while (curr_node != NULL && curr_pos < pos2)\n    {\n", "distance": 0.3146067415730337}}, {"label": "Human", "text": "->next;\n        curr_pos++;\n    }\n\n    if (curr_node == NULL)\n    {\n        printf(\"ERROR: Item not found\\n\");\n        return EXIT_FA", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "ILURE;\n    }\n\n    // Update the item\n    curr_node->item_name = item_name;\n    curr_node->price = price;\n    curr_node->quantity = quantity;\n\n    return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-18T02:48:04.073Z", "text": ";\n    }\n\n    // Update the item\n    curr_node->item_name = item_name;\n    curr_node->price = price;\n    curr_node->quantity = quantity;\n\n    return EXIT_SUCCESS;\n}\n\n//", "distance": 0.059880239520958084}}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    // Iterate", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": " to the correct position\n    unsigned int curr_pos = 1;\n    node* curr_node = *head;\n    node* prev_node = NULL;\n\n    while (curr_node != NULL && curr_pos < pos)\n    {\n        prev_node", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-18T02:49:10.830Z", "text": " to the correct position\n    unsigned int curr_pos = 1;\n    node* curr_node = *head;\n    node* prev_node = NULL;\n\n    while (curr_node != NULL && curr_pos < pos)\n    {\n        prev_node"}}, {"label": "Codex", "text": " = curr_node;\n        curr_node = curr_node->next;\n        curr_pos++;\n    }\n\n    if (curr_node == NULL)\n    {\n        printf(\"ERROR: Item not found\\n\");\n        return EXIT_FAIL", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-18T02:49:14.593Z", "text": " = curr_node;\n        curr_node = curr_node->next;\n        curr_pos++;\n    }\n\n    if (curr_node == NULL)\n    {\n        printf(\"ERROR: Item not found\\n\");\n        return EXIT_FAIL"}}, {"label": "Human", "text": "URE;\n    ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "}\n\n    // Remove the node\n    if (prev_node == NULL) {\n        *head = curr_node->next;\n    } else {\n        prev_node->next = curr_node->next;\n    }\n\n    free(curr_node);\n\n", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-18T02:49:28.599Z", "text": "}\n\n    // Remove the node\n    if (prev_node == NULL) {\n        *head = curr_node->next;\n    } else {\n        prev_node->next = curr_node->next;\n    }\n\n    free(curr_node);\n\n"}}, {"label": "Human", "text": "    return EXIT_SUCCESS;\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "    // Choose the first node\n    unsigned int curr_pos = 1;\n    node* curr_node = *head;\n    node* prev_node = NULL;\n    while (curr_node != NULL && curr_pos < pos1)\n    {\n      ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-18T02:53:13.019Z", "text": "// Iterate to the correct position\n    unsigned int curr_pos = 1;\n    node* curr_node = *head;\n    node* prev_node = NULL;\n    while (curr_node != NULL && curr_pos < pos2)\n    {\n", "distance": 0.17415730337078653}}, {"label": "Human", "text": "  prev_node = curr_node;", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Codex", "text": "\n        curr_node = curr_node->next;\n        curr_pos++;\n    }\n\n    if (curr_node == NULL)\n    {\n        printf(\"ERROR: Item not found\\n\");\n        return EXIT_FAILURE;\n    }", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-18T02:54:16.922Z", "text": "\n        curr_node = curr_node->next;\n        curr_pos++;\n    }\n\n    if (curr_node == NULL)\n    {\n        printf(\"ERROR: Item not found\\n\");\n        return EXIT_FAILURE;\n    }"}}, {"label": "Human", "text": "\n\n    // Choose the second node\n    unsigned int curr_pos2 = 1", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Codex", "text": ";\n    node* curr_node2 = *head;\n    node* prev_node2 = NULL;\n    while (curr_node2 != NULL && curr_pos2 < pos2)\n    {\n        prev_node2 = curr_node2;\n", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-18T04:10:48.727Z", "text": ";\n    node* curr_node2 = *head;\n    node* prev_node2 = NULL;\n    while (curr_node2 != NULL && curr_pos2 < pos2)\n    {\n        prev_node2 = curr_node2;\n"}}, {"label": "Human", "text": "        curr_node2 = curr_node2->next;\n        curr_pos2++;\n    }\n\n    if (curr_node2 == NULL)\n    {\n        printf(\"ERROR: Item not found\\n\");\n        return EXIT_FAILURE;\n    }\n\n    // Swap the nodes\n    node* temp_node = curr_node->next;\n    curr_node->next = curr_node2->next;\n    curr_node2->next = temp_node;\n\n    // Swap the remaining node\n    if (prev_node == NULL) {\n        *head = curr_node2;\n    } else {\n     ", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "   prev_node->next = curr_node2;\n    }\n\n    if (prev_node2 == NULL) {\n        *head = curr_node;\n    } else {\n        prev_node2->next = curr_node;\n    }\n\n    return EXIT_SUCCESS;", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-18T03:13:28.201Z", "text": "// Update the node at the other positon\n    if (prev_node2 == NULL) {\n        *head = curr_node;\n    } else {\n        prev_node2->next = curr_node;\n    }\n\n    return EXIT_SUCCESS;", "distance": 0.18994413407821228}}, {"label": "Human", "text": "\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_find_highest_price_item_position(node *head, int *pos) {\n    float max = -1.0;\n    int curr_pos = 0;\n    int max_pos = 0;\n\n    // Iterating through the list determining max\n    node* curr_node = head;\n\n    while(curr_node != NULL) {\n        if(curr_node->price > max) {\n            max = curr_node->price;\n            max_pos = curr_pos;\n        }\n        curr_pos++;\n        curr_node = curr_node->next;\n    }\n\n    // Update *pos\n    *pos = curr_pos;\n\n    return EXIT_SUCCESS;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "    float sum = 0;\n    \n    // Iterate throug", "function": "list_cost_sum", "extra_info": null}, {"label": "CodexApproximate", "text": "h the list\n    node* curr_node = head;\n\n    while(curr_node != NULL){\n        float item_price = curr_node->price;\n        int item_quantity = curr_node-", "function": "list_cost_sum", "extra_info": {"ts": "2022-04-18T02:55:27.495Z", "text": " = 1;\n    node* curr_node2 = *head;\n    node* prev_node2 = NULL;\n    while (curr_node2 != NULL && curr_pos2 < pos2)\n    {\n        prev_node2 = curr_node2", "distance": 0.49673202614379086}}, {"label": "Human", "text": ">quantity;\n\n        sum += item_price*item_quantity;\n        curr_node = curr_node->next;\n    }\n\n    // Updating total\n    *total = sum;\n\n    return EXIT_SUCCESS;\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    // Open a file for writing\n    // fp = fopen(filename, \"w+\");\n\n\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    // Load in from file\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "    node* curr_node = *head;\n\n    // Iterate through the list\n    while(curr_node != NULL) {\n        curr_node = curr_node->next;\n    }\n\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 3265, "matched_exact": 862, "matched_approx": 1236, "matched_human": 2610, "matched_total": 7973, "suggestions_matched": 5, "suggestions_approx": 8, "suggestions_total": 26, "suggestions_with_funcs": 21}}
{"uuid": "74bd8618-cc17-42a6-8657-abebc4b6b500", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "\n    // create a string representation of the node head.", "function": "list_item_to_string", "extra_info": null}, {"label": "Codex", "text": "\n    // Since only a single item is being printed, the string should be\n    // formatted exactly as shown in the sample output for list_item_to_string\n    if (head == NULL) {\n        str = \"\";\n        return EXIT_FAILURE;\n    }", "function": "list_item_to_string", "extra_info": {"ts": "2022-04-13T21:55:31.294Z", "text": "\n    // Since only a single item is being printed, the string should be\n    // formatted exactly as shown in the sample output for list_item_to_string\n    if (head == NULL) {\n        str = \"\";\n        return EXIT_FAILURE;\n    }"}}, {"label": "CodexApproximate", "text": "\n    int quantity = head->quantity;\n    char item_name[MAX_ITEM_PRINT_LEN];\n    strncpy(item_name, head->item_name, MAX_ITEM_PRINT_LEN);\n    float price = head->pri", "function": "list_item_to_string", "extra_info": {"ts": "2022-04-13T21:55:40.247Z", "text": "\n    int quantity = head->data.quantity;\n    char item_name[MAX_ITEM_PRINT_LEN];\n    strncpy(item_name, head->data.item, MAX_ITEM_PRINT_LEN);\n    float price = head", "distance": 0.10975609756097561}}, {"label": "Human", "text": "ce;\n    sprintf(str, \"%d * %s @ $%.2f ea\", quantity, item_name, price);\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    // print all nodes in the list based on string returned by list_item_to_string\n    // print the node at the head of the list\n    char tmp[MAX_ITEM_PRINT_LEN];\n    node *tmp_node = head;\n    while (tmp_node != NULL) {\n        list_item_to_string(tmp_node, tmp);\n        tmp_node = tmp_node->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n    // create a new node", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": " with the item\n    node *new_node = malloc(sizeof(node));\n    new_node->item_name = item_name;\n    new_node->quantity = quantity;\n    new_node->price = price;\n\n    // add the node to the list", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-13T21:14:12.284Z", "text": " with the item\n    node *new_node = malloc(sizeof(node));\n    new_node->item_name = item_name;\n    new_node->quantity = quantity;\n    new_node->price = price;\n\n    // add the node to the list"}}, {"label": "Human", "text": " at position given by pos\n    node *tmp_node;\n    tmp_node = *head;\n    unsigned int i = 1;\n    while(tmp_node != NULL && i < pos) {\n        tmp_node = tmp_node->next;\n        i++;\n    }\n    if(tmp_node == NULL) {\n        new_node->next = NULL;\n    } else {\n        new_node->next = tmp_node->next;\n        tmp_node->next = new_node;\n    }\n\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n    // update the node at the given position.", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "\n    node *tmp_node;\n    tmp_node = *head;\n    unsigned int i = 1;\n    while(tmp_node != NULL && i < pos) {\n        tmp_node = tmp_node->next;\n        i++;\n    }\n    if", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-13T21:39:40.717Z", "text": "    node *tmp_node;\n    tmp_node = *head;\n    unsigned int i = 1;\n    while(tmp_node != NULL && i < pos) {\n        tmp_node = tmp_node->nsext;\n        i++;\n    }\n    if", "distance": 0.011904761904761904}}, {"label": "Human", "text": "(", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "tmp_node == NULL) {\n        return EXIT_FAILURE;\n    } else {\n        tmp_node->item_name = item_name;\n        tmp_node->price = price;\n        tmp_node->quantity = quantity", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-13T21:19:27.008Z", "text": "tmp_node == NULL) {\n        new_node->next = NULL;\n    } else {\n        new_node->next = tmp_node->next;\n        tmp_node->next = new_node;\n    }\n\n    return EXIT_SUCCESS;\n}", "distance": 0.4797687861271676}}, {"label": "Human", "text": ";\n        return EXIT_SUCCESS;\n    }\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n    // remove the node at postion pos.", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "\n    node *tmp_node;\n    tmp_node = *head;\n    unsigned int i = 1;\n    while(tmp_node != NULL && i < pos) {\n        tmp_node = tmp_node->next;\n        i++;\n    }\n    if(", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-13T21:19:18.513Z", "text": "\n    node *tmp_node;\n    tmp_node = *head;\n    unsigned int i = 1;\n    while(tmp_node != NULL && i < pos) {\n        tmp_node = tmp_node->next;\n        i++;\n    }\n    if("}}, {"label": "CodexApproximate", "text": "tmp_node == NULL) {\n        return EXIT_FAILURE;\n    } else {\n        tmp_node->next->next = tmp_node->next;\n        tmp_node->next->next = tmp_node->next;\n        free(tmp_node);\n    ", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-13T21:39:47.555Z", "text": "tmp_node == NULL) {\n        return EXIT_FAILURE;\n    } else {\n        tmp_node->item_name = new_node->item_name;\n        tmp_node->price = new_node->price;\n        tmp_node->quantity =", "distance": 0.28804347826086957}}, {"label": "Human", "text": "    return EXIT_SUCCESS;\n    }\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "\n    // swap the nodes at positions pos1 a", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "nd pos2.\n    node *tmp_node1;\n    tmp_node1 = *head;\n    unsigned int i = 1;\n    while(tmp_node1 != NULL && i < pos1) {\n        tmp_node1 = tmp_node1->next;\n       ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-13T21:41:14.834Z", "text": ".\n    node *tmp_node;\n    tmp_node = *head;\n    unsigned int i = 1;\n    while(tmp_node != NULL && i < pos) {\n        tmp_node = tmp_node->nsext;\n        i++;\n    }\n", "distance": 0.15853658536585366}}, {"label": "Codex", "text": " i++;\n    }\n    if(tmp_node1 == NULL) {\n        return EXIT_FAILURE;\n    } else {\n        node *tmp_node2;\n        tmp_node2 = *head;\n        i = 1;\n        while(tmp_", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-13T21:42:14.938Z", "text": " i++;\n    }\n    if(tmp_node1 == NULL) {\n        return EXIT_FAILURE;\n    } else {\n        node *tmp_node2;\n        tmp_node2 = *head;\n        i = 1;\n        while(tmp_"}}, {"label": "Human", "text": "node2 != NULL && i < pos2) {\n            tmp_node2 = tmp_node2->next;\n            i++;\n        }\n        ", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "if(tmp_node2 == NULL) {\n            return EXIT_FAILURE;\n        } else {\n            node *tmp_node3;\n            tmp_node3 = tmp_node1->next;\n            tmp_no", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-13T21:41:26.679Z", "text": "if(tmp_node == NULL) {\n        return EXIT_FAILURE;\n    } else {\n        tmp_node->nsext->next = tmp_node->next;\n        tmp_node->next->nsext = tmp_node->nsext;\n", "distance": 0.41975308641975306}}, {"label": "Human", "text": "de1->next = tmp_node2;\n            tmp_node3->next = tmp_node1;\n            tmp_node2->next = tmp_node3;\n        }\n    }\n    return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4623, "matched_exact": 754, "matched_approx": 1015, "matched_human": 1324, "matched_total": 7716, "suggestions_matched": 4, "suggestions_approx": 6, "suggestions_total": 18, "suggestions_with_funcs": 14}}
{"uuid": "925cb076-503f-4a8e-b8d9-0aac9efe5955", "parts": [{"label": "Human", "text": "#include <stdio.h>\n", "function": null, "extra_info": null}, {"label": "Template", "text": "#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was\n", "function": null, "extra_info": null}, {"label": "Template", "text": "// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n", "function": "list_init", "extra_info": null}, {"label": "Human", "text": "    int status = EXIT_SUCCESS;\n\n    if (head == NULL)\n    {\n        status = EXIT_FAILURE;\n    }\n    else\n    {\n        *head = NULL;\n    }\n    return status;\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_init", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// \"quantity * item_name @ $price ea\", where item_name is a string and\n", "function": null, "extra_info": null}, {"label": "Template", "text": "// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "\n    // TODO: Implement this function,\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    int status = EXIT_SUCCESS;\n    if (head == NULL)\n    {\n        status = EXIT_FAILURE;\n    }\n    else\n    {\n        if (head->next == NULL)\n        {\n            sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n        }\n        else\n        {\n            sprintf(str, \"%d * %s @ $%.2f ea, %s\", head->quantity, head->item_name, head->price, list_item_to_string(head->next, str));\n        }\n    }\n    return status;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "\n\n\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// \"pos: quantity * item_name @ $price ea\", where\n//   pos is the position of the item in the list,\n//   item_name is the item_name of the item and\n", "function": null, "extra_info": null}, {"label": "Template", "text": "//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// It should return a newline character at the end of each item.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    // TODO: Implement this function,\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    int pos = 0;\n    char str[MAX_ITEM_PRINT_LEN];\n    while (head != NULL)\n    {\n        pos++;\n        if (list_item_to_string(head, str) == EXIT_FAILURE)\n        {\n            return EXIT_FAILURE;\n        }\n        printf(\"%d: %s\\n\", pos, str);\n        head = head->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}, {"label": "Human", "text": "\n\n// add a new item (name, price, quantity) to the list at position pos,\n", "function": null, "extra_info": null}, {"label": "Template", "text": "//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    // TODO: Implement this\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    int status = EXIT_SUCCESS;\n    node *new_node = NULL;\n    if (head == NULL || item_name == NULL || quantity < 0 || pos < 0)\n    {\n        status = EXIT_FAILURE;\n    }\n    else\n    {\n        new_node = (node*)malloc(sizeof(node));\n        strcpy(new_node->item_name, item_name);\n      ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "  new_node->price = price;\n        new_node->quantity = quantity;\n        new_node->next = NULL;\n        if (*head == NULL)\n        {\n            *head = new_node;\n            return ", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-01T02:43:01.241Z", "text": " new_node->price = price;\n    new_node->quantity = quantity;\n    if (head == NULL)\n    {\n        status = EXIT_FAILURE;\n    }\n    else\n    {\n        if(pos == 0)\n        {\n           ", "distance": 0.4262295081967213}}, {"label": "Human", "text": "status;\n        }\n        else if ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "(pos == 0)\n        {\n            new_node->next = *head;\n            *head = new_node;\n        }\n        else\n        {\n            status = list_add_item_at_pos(&((*head)->next), item_name, price,", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-01T02:46:13.420Z", "text": "_node->quantity = quantity;\n            new_node->next = *head;\n            *head = new_node;\n        }\n        else\n        {\n            if (list_add_item_at_pos(&(*head)->next, item_name, price,", "distance": 0.17258883248730963}}, {"label": "Human", "text": " quantity, pos - 1);\n            if (status == EXIT_FAILURE)\n            {\n                free(new_node);\n                return status;\n            }\n            if ((*head)->next == NULL)\n            {\n                (*head)->next = new_node;\n            }\n        }\n    }\n    return status;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n\n\n\n\n\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    // TODO: Implement this function,\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "   ", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": " while (pos--) {\n        head = &(*head)->next;\n    }\n\n    node* temp = *head;\n    temp->item_name = item_name;\n    temp->price = price;\n    temp->quantity = quantity;\n\n    retu", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-01T01:22:47.969Z", "text": "while(pos--){\n        head = &(*head)->next;\n    }\n    \n    node* temp = *head;\n    temp->item_name = item_name;\n    temp->price = price;\n    temp->quantity = quantity;\n    \n   ", "distance": 0.06779661016949153}}, {"label": "Human", "text": "rn EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "{\n    // TODO: Implement this function,\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    while (pos--) {\n        head = &(*head)->next;\n    }\n\n    node* temp = *head;\n    *head = temp->next;\n    free(temp);\n\n    return EXIT_SUCCESS;\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    // TODO: Implement this function,\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    while (pos1--) {\n        head = &(*head)->next;\n    }\n\n    node* temp = *head;\n    *head = temp->next;\n\n    while (pos2--) {\n        head = &(*head)->next", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": ";\n    }\n\n    node* temp2 = *head;\n    *head = temp2->next;\n\n    if (temp2->next == NULL) {\n        temp2->next = temp;\n    }\n    else {\n        temp2->next = temp->next;", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-01T01:24:22.643Z", "text": " }\n    \n    node* temp2 = *head;\n    *head = temp2->next;\n    \n    if(temp2->next == NULL){\n        temp2->next = temp;\n    }\n    else{\n        temp2->next = temp->next;", "distance": 0.0650887573964497}}, {"label": "Human", "text": "\n    }\n\n    temp->next = temp2;\n    return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "\n\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_find_highest_price_item_position(node *head, int *pos)\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "{\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "    // TODO: Implement this function,\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "CodexApproximate", "text": "    node* curr = head;\n    node* max = head;\n    int position = 0;\n\n    while (curr != NULL) {\n        if (curr->price > max->price) {\n            max = curr;\n            position = 1;\n        }\n        curr ", "function": "list_find_highest_price_item_position", "extra_info": {"ts": "2022-05-01T01:25:39.896Z", "text": "    node* curr = head;\n        float cost = 0;\n        \n        while(curr != NULL){\n            cost += curr->price * curr->quantity;\n            curr = curr->next;\n        }\n        \n        *total = cost;\n", "distance": 0.4567307692307692}}, {"label": "Human", "text": "= curr->next;\n        position++;\n    }\n\n    *pos = position;\n\n    return EXIT_SUCCESS;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "\n\n\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_cost_sum", "extra_info": null}, {"label": "Codex", "text": "// TODO: Implement this ", "function": "list_cost_sum", "extra_info": {"ts": "2022-05-01T01:45:53.862Z", "text": "// TODO: Implement this "}}, {"label": "Human", "text": "function,\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "    node* curr = head;\n    flo", "function": "list_cost_sum", "extra_info": null}, {"label": "CodexApproximate", "text": "at cost = 0;\n\n    while (curr != NULL) {\n        cost += curr->price * curr->quantity;\n        curr = curr->next;\n    }\n\n    *total = cost;\n\n    return EX", "function": "list_cost_sum", "extra_info": {"ts": "2022-05-01T01:25:59.741Z", "text": "\n        fprintf(file,\"%s,%f,%d\\n\",curr->item_name,curr->price,curr->quantity);\n        curr = curr->next;\n    }\n    \n    fclose(file);\n    \n    return EX", "distance": 0.487012987012987}}, {"label": "Human", "text": "IT_SUCCESS;\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// item_name,price,quantity\\n\n", "function": null, "extra_info": null}, {"label": "Template", "text": "//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_save", "extra_info": null}, {"label": "Codex", "text": "// TODO: Implement this ", "function": "list_save", "extra_info": {"ts": "2022-05-01T02:44:21.353Z", "text": "// TODO: Implement this "}}, {"label": "Human", "text": "function,\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    FILE* file = fopen(filename, \"w\");\n    if (file == NULL) {\n        printf(\"Unable to open the file\");\n        return EXIT_FAILURE;\n    }\n\n    node* curr = head;\n    while (curr != NUL", "function": "list_save", "extra_info": null}, {"label": "CodexApproximate", "text": "L) {\n        fprintf(file, \"%s,%f,%d\\n\", curr->item_name, curr->price, curr->quantity);\n        curr = curr->next;\n    }\n\n    fclose(file);\n\n    return EX", "function": "list_save", "extra_info": {"ts": "2022-05-01T01:26:02.083Z", "text": "\n        fprintf(file,\"%s,%f,%d\\n\",curr->item_name,curr->price,curr->quantity);\n        curr = curr->next;\n    }\n    \n    fclose(file);\n    \n    return EX", "distance": 0.1038961038961039}}, {"label": "Human", "text": "IT_SUCCESS;\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// item_name,price,quantity\\n\n", "function": null, "extra_info": null}, {"label": "Template", "text": "//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    return EXIT_SUCCESS;\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// de-duplicate the list by combining items with the same name\n", "function": null, "extra_info": null}, {"label": "Template", "text": "//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_deduplicate(node **head)\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "{\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "\n    ", "function": "list_deduplicate", "extra_info": null}, {"label": "Codex", "text": "// TODO: Implement this ", "function": "list_deduplicate", "extra_info": {"ts": "2022-05-01T02:45:29.566Z", "text": "// TODO: Implement this "}}, {"label": "Human", "text": "function,\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "    node *ptr1, *ptr2, *dup;\n    ptr1 = head;\n\n    /* Pick elements", "function": "list_deduplicate", "extra_info": null}, {"label": "CodexApproximate", "text": " one ", "function": "list_deduplicate", "extra_info": {"ts": "2022-05-01T01:46:02.534Z", "text": " The ", "distance": 0.4}}, {"label": "Human", "text": "by", "function": "list_deduplicate", "extra_info": null}, {"label": "CodexApproximate", "text": " one ", "function": "list_deduplicate", "extra_info": {"ts": "2022-05-01T01:46:00.448Z", "text": " The ", "distance": 0.4}}, {"label": "Human", "text": "*/\n    while (ptr1 != NULL && ptr1->next != NULL) {\n        ptr2 = ptr1;\n\n        while (ptr2->next != NULL) {\n            if (ptr1->data == ptr2->next->data) {\n                dup = ptr2->next;\n                ptr2->next = ptr2->next->next;\n                delete (dup);\n            }\n            else\n                ptr2 = ptr2->next;\n        }\n        ptr1 = ptr1->next;\n    }\n\n    return EXIT_SUCCESS;\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 3232, "matched_exact": 72, "matched_approx": 1252, "matched_human": 3735, "matched_total": 8291, "suggestions_matched": 3, "suggestions_approx": 9, "suggestions_total": 18, "suggestions_with_funcs": 15}}
{"uuid": "a3edd088-a9ab-4b80-ae98-01ffcfca615b", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "\n    // Allocate String\n    if (head == NULL) return EXIT_FAILURE;\n\n    // Else print out node \n    else{\n        char * temp = malloc(MAX_ITEM_PRINT_LEN);\n        \n        // Store name into string \n        char name[100] = \"\";\n        strcpy(name, head->item_name);\n\n        // Store quantity into string \n        char quantity[10] = \"\";\n        sprintf(quantity, \"%d\", head->quantity);\n\n        // Store price into string \n        float price = head->price;\n        char price_arr[MAX_ITEM_PRINT_LEN]; \n        gcvt(price, sizeof(price), price_arr);\n\n        // Print out string with quantity, name, price and quantity \n        sprintf(temp, \"%d %s %s %s\", head->quantity, name, price_arr, \"ea\");   \n        strcpy(str, temp);\n\n        free(temp);\n\n        //Changing int to String \n        char quant[MAX_ITEM_PRINT_LEN];", "function": "list_item_to_string", "extra_info": null}, {"label": "CodexApproximate", "text": " \n        int quantity = head->quantity;\n        itoa(quantity, quant, sizeof(quantity)); \n\n        // Format the string\n        sprintf(temp, \"%d * %s @ $%.2f ea\", quantity, item_name, price);\n\n        // Copy the", "function": "list_item_to_string", "extra_info": {"ts": "2022-04-18T06:19:14.902Z", "text": "head->item_name;\n        float price = head->price;\n        int quantity = head->quantity;\n\n        // Format the string\n        sprintf(temp, \"%d * %s @ $%.2f ea\", quantity, item_name, price);\n\n        // Copy the", "distance": 0.2570093457943925}}, {"label": "Human", "text": "\n    }\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    node* curr_node = head; \n    int counter = 1; \n    while(curr_node != NULL) {\n        printf(\"%d: %d * %s @ $%.2f ea\\n\", counter, curr_node->quantity, curr_node->item_name, curr_node->price);\n        curr_node = curr_node->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "int position = 0; \n    node *curr_node = *head;\n    for (int i = 0; i < pos; i++){\n        if (position != pos){\n            position++; \n            curr_node = curr_node->next; \n", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-26T19:18:47.016Z", "text": "int position = 0; \n    node *curr_node = *head;\n    for (int i = 0; i < pos; i++){\n        if (position != pos){\n            position++; \n            curr_node = curr_node->next; \n"}}, {"label": "Human", "text": "        }\n        else{\n            node *new_node = malloc(sizeof(node)", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "); \n            // New node contents \n            new_node->item_name = item_name;\n            new_node->price = price;\n            new_node->quantity = quantity;\n            // new_node->pos = pos; \n            c", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-18T05:59:36.835Z", "text": "node *new_node = malloc(sizeof(node));\n            new_node->item_name = item_name;\n            new_node->price = price;\n            new_node->quantity = quantity;\n            new_node->pos = pos;\n            new_", "distance": 0.19248826291079812}}, {"label": "Human", "text": "urr_node->next = new_node; // Connect the previous node to the new node\n        }\n    }\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n    unsigned curr_pos = 0; // Initialize the current position to 0 \n    node* curr_node = head; \n    while (curr_pos != pos", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "){\n        if (curr_pos == pos){\n            curr_node->item_name = item_name;\n            curr_node->price = price;\n            curr_node->quantity = quantity;\n        }\n        curr_pos++;\n        cur", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-26T19:32:24.164Z", "text": "){\n        if (curr_pos == pos){\n            curr_node->item_name = item_name;\n            curr_node->price = price;\n            curr_node->quantity = quantity;\n        }\n        curr_pos++;\n        cur"}}, {"label": "Human", "text": "r_node = curr_node->next; \n    }\n    return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    unsigned curr_pos = 0; \n    node* curr_node = head; \n    node* prev_node = node(); \n    while (curr_pos != pos && curr_pos->next is not None){\n        if(curr_pos == pos){\n            prev_node->next = curr_node->next; \n            return EXIT_SUCCESS\n        }\n        else{\n            curr_pos++;\n            prev_node = curr_node; \n            curr_node = curr_node->next; \n        }\n    }\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4648, "matched_exact": 382, "matched_approx": 427, "matched_human": 1865, "matched_total": 7322, "suggestions_matched": 2, "suggestions_approx": 2, "suggestions_total": 6, "suggestions_with_funcs": 4}}
{"uuid": "a4b3a969-44a1-4cea-87f5-86393eb85908", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    if", "function": "list_item_to_string", "extra_info": null}, {"label": "Codex", "text": " (head == NULL) {\n        str = \"\";\n        return EXIT_FAILURE;\n    }\n    node *current = head;\n    while (current != NULL) {\n        sprintf(str, \"%d * %s @ $%.2f ea\", current->", "function": "list_item_to_string", "extra_info": {"ts": "2022-04-28T17:18:46.186Z", "text": " (head == NULL) {\n        str = \"\";\n        return EXIT_FAILURE;\n    }\n    node *current = head;\n    while (current != NULL) {\n        sprintf(str, \"%d * %s @ $%.2f ea\", current->"}}, {"label": "Human", "text": "quantity, current->item_name, current->price);\n        current = current->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "CodexApproximate", "text": "    if (head == NULL) {\n        printf(\"\\n\");\n        return EXIT_FAILURE;\n    }\n    node *current = head;\n    int pos = 1;\n    while (current != NULL) {\n        printf(\"%", "function": "list_print", "extra_info": {"ts": "2022-04-28T17:05:54.007Z", "text": "if(head == NULL){\n        return EXIT_FAILURE;\n    }\n    if(pos == 0){\n        return EXIT_FAILURE;\n    }\n    node *temp = *head;\n    int count = 1;\n    while(temp != NULL", "distance": 0.49707602339181284}}, {"label": "Human", "text": "d: %d * %s @ $%.2f ea\\n\", pos, current->quantity, current->item_name, current->price);\n        current = current->next;\n        pos++;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "\n\n// insert a new item before the specified position", "function": null, "extra_info": null}, {"label": "CodexApproximate", "text": "\n// (1 = ", "function": null, "extra_info": {"ts": "2022-04-28T17:24:34.332Z", "text": "\n// This ", "distance": 0.4444444444444444}}, {"label": "Human", "text": "first item, 2 = second item, etc)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "if(head == NULL || pos == 0){\n        return EXIT_FAILURE;\n    }\n    node *current = *head;\n    if(pos == 1){\n        node *new_node = malloc(sizeof(node));\n        new_node->item", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-28T17:21:08.276Z", "text": "if(head == NULL || pos == 0){\n        return EXIT_FAILURE;\n    }\n    node *current = *head;\n    if(pos == 1){\n        node *new_node = malloc(sizeof(node));\n        new_node->item"}}, {"label": "Human", "text": "_name = item_name;\n        new_node->", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "price = price;\n        new_node->quantity = quantity;\n        new_node->next = current;\n        *head = new_node;\n    }else{\n        int i;\n        for (i = 1; i < (pos - 1); i++){\n            if(current->next == NULL){\n  ", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-28T17:04:20.167Z", "text": "(sizeof(node));\n            new_node->quantity = quantity;\n            new_node->price = price;\n            new_node->item_name = item_name;\n            new_node->next = current->next;\n            current->next = new_node;", "distance": 0.47297297297297297}}, {"label": "Human", "text": "              break;\n            }\n            current = current->next;\n        }\n        nod", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "e *new_node = malloc(sizeof(node));\n        new_node->item_name = item_name;\n        new_node->price = price;\n        new_node->quantity = quantity;\n        new_node->next = current->next;\n        current->next = new_node;", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-28T17:04:22.683Z", "text": "(sizeof(node));\n            new_node->quantity = quantity;\n            new_node->price = price;\n            new_node->item_name = item_name;\n            new_node->next = current->next;\n            current->next = new_node;", "distance": 0.34234234234234234}}, {"label": "Human", "text": "\n    }\n    return EXIT_SUCCESS;\n\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if(head == NULL || pos", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": " == 0){\n        return EXIT_FAILURE;\n    }\n    node *current = *head;\n    if(pos == 1){\n        current->item_name = item_name;\n        current->price = price;\n        current", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-26T17:15:51.382Z", "text": "if(head == NULL){\n        return EXIT_FAILURE;\n    }\n    if(pos == 0){\n        strcpy((*head)->item_name, item_name);\n        (*head)->price = price;\n        (*head)->quantity", "distance": 0.4342857142857143}}, {"label": "Human", "text": "->quantity = quantity", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": ";\n    }else{\n        int i;\n        for (i = 1; i < pos; i++){\n            if(current->next == NULL){\n                break;\n            }\n            current = cu", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-26T17:05:31.610Z", "text": ";\n    }\n    node *curr = *head;\n    for(int i=1; i < pos1; i++){\n        if(curr->next){\n            curr = curr->next;\n        }else{\n            return EXIT_FAIL", "distance": 0.4723926380368098}}, {"label": "Human", "text": "rrent->next;\n        }\n        current->item_name = item_name;\n        current->price = price;\n        current->quantity = quantity;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if(head == NULL || pos == 0){\n        return EXIT_FAILURE;\n    }\n    node *current", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": " = *head;\n    if(pos == 1){\n        *head = current->next;\n        free(current);\n    }else{\n        int i;\n        for (i = 1; i < (pos - 1); i++){\n            if(current", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-30T20:24:52.732Z", "text": " = *head;\n    if(pos2 == 1){\n        current2 = current2->next;\n        pos2++;\n    }else{\n        int i;\n        for (i = 1; i < (pos2 - 1); i++){\n            if(current2", "distance": 0.14035087719298245}}, {"label": "Human", "text": "->", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "next == NULL){\n                break;\n            }\n            current = current->next;\n        }\n        node *temp = current->next;\n        current->next = temp->next;\n        free(temp);\n    }\n    return EXIT_S", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-30T20:31:31.726Z", "text": "next == NULL){\n            break;\n        }\n        current = current->next;\n    }\n    current2 = current->next;\n    current->next = current2;\n    current2->next = current1;\n    current1->next = current2->next;\n   ", "distance": 0.43457943925233644}}, {"label": "Human", "text": "UCCESS;\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    if(head == NULL){\n        retur", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "n EXIT_FAILURE;\n    }\n    node *current = *head;\n    node *current1 = current;\n    node *current2 = current;\n    int i;\n    for (i = 1; i < pos1; i++){\n        if(current->next == NULL){\n            break;\n        }\n      ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-30T20:26:03.310Z", "text": "next;\n        if(pos2 == 1){\n            return EXIT_FAILURE;\n        }else{\n            int i;\n            for (i = 2; i < pos2; i++){\n                if(current2->next == NULL){\n                    break;\n               ", "distance": 0.4864864864864865}}, {"label": "Human", "text": "  current = current->next;\n    }\n    current1 = current->next;\n    for (i = 1; i < pos2; i++){\n        if(current->", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Codex", "text": "next == NULL){\n            break;\n        }\n        current = current->next;\n    }\n    current2 = current->next;\n    current->next = current2;\n    current2->next = current1;\n    current1->next = current2->next;\n   ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-30T20:31:34.153Z", "text": "next == NULL){\n            break;\n        }\n        current = current->next;\n    }\n    current2 = current->next;\n    current->next = current2;\n    current2->next = current1;\n    current1->next = current2->next;\n   "}}, {"label": "Human", "text": " return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "    if(head == NULL || pos == NULL){\n        return EXIT_FAILURE;\n    }\n    if(head->next == NULL){\n        *pos = 1;\n        return EXIT_SUCCESS;\n    }\n    node *current = head;\n   ", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Codex", "text": " int i = 1;\n    float max = 0.0;\n    while (current != NULL) {\n        if(current->price > max){\n            max = current->price;\n            *pos = i;\n        }\n        current = current->next;\n        i++;", "function": "list_find_highest_price_item_position", "extra_info": {"ts": "2022-04-30T20:28:48.777Z", "text": " int i = 1;\n    float max = 0.0;\n    while (current != NULL) {\n        if(current->price > max){\n            max = current->price;\n            *pos = i;\n        }\n        current = current->next;\n        i++;"}}, {"label": "Human", "text": "\n    }\n    return EXIT_SUCCESS;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "    if()\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    if(head!=NULL){\n        \n        return EXIT_SUCCESS;\n    }\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4518, "matched_exact": 780, "matched_approx": 1569, "matched_human": 1337, "matched_total": 8204, "suggestions_matched": 4, "suggestions_approx": 9, "suggestions_total": 30, "suggestions_with_funcs": 26}}
{"uuid": "a5ba06a2-cd4d-4aed-92ac-eeee80fe3e73", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL || str == NULL) {\n        return EXIT_FAILURE;\n    }\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    free(str);\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "CodexApproximate", "text": "    //\n    // Hint: There are many ways to do this\n    //\n    int i = 0; char* str = malloc(MAX_ITEM_PRINT_LEN);\n    node* cur = head;\n    while (cur != NULL) {\n        list_item_to_stri", "function": "list_print", "extra_info": {"ts": "2022-04-16T21:47:06.841Z", "text": "//\n    // Hint: There are many ways to do this\n    //\n    int i = 0;\n    node* current = head;\n    while (current != NULL) {\n        i++;\n        printf(\"%d: \", i);\n        list_item_to_", "distance": 0.46774193548387094}}, {"label": "Human", "text": "ng(cur, str);\n        printf(\"%d: %s\\n\", i, str);\n        i++;\n        cur = cur->next;\n    }\n    free(str);\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "//\n    // Hint: There are many ways to do this\n    //\n    node* cur = *head;\n    if(pos == 0) {\n        *head = malloc(sizeof(node));\n        (*head)->quantity = quantity;\n        (*head", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-16T22:15:36.553Z", "text": "//\n    // Hint: There are many ways to do this\n    //\n    node* cur = *head;\n    if(pos == 0) {\n        *head = malloc(sizeof(node));\n        (*head)->quantity = quantity;\n        (*head"}}, {"label": "Codex", "text": ")->price = price;\n        (*head)->item_name = malloc(sizeof(char) * (strlen(item_name) + 1));\n        strcpy((*head)->item_name, item_name);\n        (*head)->next = cur", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-16T22:15:47.148Z", "text": ")->price = price;\n        (*head)->item_name = malloc(sizeof(char) * (strlen(item_name) + 1));\n        strcpy((*head)->item_name, item_name);\n        (*head)->next = cur"}}, {"label": "Human", "text": ";\n        return EXIT_SUCCESS;\n    }\n\n    if (pos > 0) {\n        if (cur == NULL) {\n            return EXIT_FAILURE;\n        }\n        for (unsigned int i = 1; i < pos; i++) {\n            if (cur->next == NULL) {\n                return EXIT_FAILURE;\n            }\n            cur = cur->next;\n        }\n    }\n    node* new = malloc(sizeof(node));\n    new->quantity = quantity;\n    new", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "->price = price;\n    new->item_name = malloc(sizeof(char) * (strlen(item_name) + 1));\n    strcpy(new->item_name, item_name);\n    new->next = cur->next;\n    cur->", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-16T22:17:15.293Z", "text": "->price = price;\n    new->item_name = malloc(sizeof(char) * (strlen(item_name) + 1));\n    strcpy(new->item_name, item_name);\n    new->next = cur->next;\n    cur->"}}, {"label": "Human", "text": "next = new;\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    //\n    // Hint: There are many ways to do this\n    //\n    if (head == NULL || *head == NULL) {\n        return EXIT_FAILURE;\n    }\n    node* cur = *head;\n   ", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Codex", "text": " if (pos == 0) {\n        cur->quantity = quantity;\n        cur->price = price;\n        strcpy(cur->item_name, item_name);\n        return EXIT_SUCCESS;\n    }\n    for (unsigned int i = 0;", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-16T22:28:22.908Z", "text": " if (pos == 0) {\n        cur->quantity = quantity;\n        cur->price = price;\n        strcpy(cur->item_name, item_name);\n        return EXIT_SUCCESS;\n    }\n    for (unsigned int i = 0;"}}, {"label": "Codex", "text": " i < pos; i++) {\n        if (cur->next == NULL) {\n            return EXIT_FAILURE;\n        }\n        cur = cur->next;\n    }\n    cur->quantity = quantity;\n    cur->price = price;\n    strc", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-16T22:28:37.183Z", "text": " i < pos; i++) {\n        if (cur->next == NULL) {\n            return EXIT_FAILURE;\n        }\n        cur = cur->next;\n    }\n    cur->quantity = quantity;\n    cur->price = price;\n    strc"}}, {"label": "Human", "text": "py(cur->item_name, item_name);\n    return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "   ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": " //\n    // Hint: There are many ways to do this\n    //\n    if (head == NULL || *head == NULL) {\n        return EXIT_FAILURE;\n    }\n    if (pos == 0) {\n        *head = (*head)->next;\n     ", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-16T22:32:39.605Z", "text": "//\n    // Hint: There are many ways to do this\n    //\n    if (head == NULL || *head == NULL || pos1 > list_length(*head) || pos2 > list_length(*head)) {\n        return EXIT_FAILURE;\n    }", "distance": 0.3850267379679144}}, {"label": "Human", "text": "   return EXIT_SUCCESS;\n    }\n    node* cur = *head;\n    for (unsigned int i = 0; i < pos - 1; i++) {\n        if (cur->next == NULL) {\n            return EXIT_FAILURE;\n        }\n        cur = cur->next;\n    }\n    if (cur->next != NULL) {\n        cur->next = cur->next->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "//\n    // Hint: There are many ways to do this\n    //\n    if (head == NULL || *head == NULL) {\n        return EXIT_FAILURE;\n    }\n    if (pos1 == pos2) {\n        return EXIT_SUCCESS;\n    ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-16T22:34:06.754Z", "text": "//\n    // Hint: There are many ways to do this\n    //\n    if (head == NULL || *head == NULL || pos1 > list_length(*head) || pos2 > list_length(*head)) {\n        return EXIT_FAILURE;\n    }", "distance": 0.32085561497326204}}, {"label": "Human", "text": "}\n    node* prev1 = NULL;\n    node* cur1 = *head;\n    for (unsigned int i = 0; i < pos1 - 1; i++) {\n        if (cur1->next == NULL) {\n            return EXIT_FAILURE;\n        }\n        prev1 = cur1;\n        cur1 = cur1->next;\n    }\n    node* prev2 = NULL;\n    node* cur2 = *head;\n    for (unsigned int i = 0; i < pos2 - 1; i++) {\n        if (cur2->next == NULL) ", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "{\n            return EXIT_FAILURE;\n        }\n        prev2 = cur2;\n        cur2 = cur2->next;\n    }\n    node* temp = cur1->next;\n    cur1->next = cur2->next;\n    cur2->next = ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-16T22:31:20.147Z", "text": "{\n            return EXIT_FAILURE;\n        }\n        cur = cur->next;\n    }\n    if (cur->next != NULL) {\n        cur->next = cur->next->next;\n    }\n    return EXIT_SUCCESS;\n}\n", "distance": 0.4514285714285714}}, {"label": "Human", "text": "temp;\n    return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL || pos == NULL) return EXIT_FAILURE;\n    node* cur = head;\n    int max_price = 0;\n    while (cur != NULL) {\n        if (cur->price > max_price) max_price = cur->price;\n        cur = cur->next;\n    }\n    pos = &max_price;\n    return EXIT_SUCCESS;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL) return EXIT_FAILURE;\n    node* cur = head;\n    float total_cost = 0;\n    while (cur != NULL) {\n        total_cost += cur->quantity*cur->price;\n        cur = cur->next;\n    }\n    total = &total_cost;\n    return EXIT_SUCCESS;\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    FILE * file;\n    file = fopen(filename, \"w\");\n    node * cur = head;\n    if (file == NULL) return EXIT_FAILURE;\n    while (cur != NULL) {\n        fprintf(file, \"%s,%f,%d\\n\", cur->item_name, cur->price, cur->quantity);\n        cur = cur->next;\n    }\n    fclose(file);\n    return EXIT_SUCCESS;\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    FILE * file;\n    file = fopen(filename, \"r\");\n    if (file == NULL) return EXIT_FAILURE;\n    node * cur = *head;\n    if (cur == NULL) return EXIT_FAILURE;\n    while (cur->next != NULL) cur = cur->next;\n    char * new_name; int new_price; int new_quant;\n    while (fscanf(file, \"%s,%d,%d\\n\", new_name", "function": "list_load", "extra_info": null}, {"label": "CodexApproximate", "text": ", &new_price, &new_quant) > 0) {\n        node * new = malloc(sizeof(node));\n        new->item_name = new_name;\n        new->price = new_price;\n        new->quantity = new_quant;", "function": "list_load", "extra_info": {"ts": "2022-04-16T21:34:40.167Z", "text": " *head_copy = *head, *previous = NULL;\n    node *new_node = malloc(sizeof(node));\n    new_node->name = item_name;\n    new_node->price = price;\n    new_node->quantity = quantity;", "distance": 0.4406779661016949}}, {"label": "Human", "text": "\n        cur->next = new;\n        new->next = NULL;\n        cur = cur->next;\n        if (cur == NULL) return EXIT_FAILURE;\n    }\n    if (fscanf(file, \"%s,%d,%d\\n\", new_name, &new_price, &new_quant) < 0) return EXIT_FAILURE;\n    fclose(file);\n    return EXIT_SUCCESS;\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "\n    // two iter nodes. one to go through and another to find duplicates for each node. \n    // when dup found, remove\n\n    node * main = *head;\n    node * findDup = *head;\n    int count = 0;\n    int dupCount;\n\n    if (main == NULL || findDup == NULL) return EXIT_FAILURE;\n\n    while (main->next != NULL) {\n        findDup = *head;\n        dupCount = 0;\n        while (findDup->item_name != main->next->item_name) {\n            findDup = findDup->next;\n            dupCount ++;\n        }\n        if (dupCount <= count) { // found duplicate\n            findDup->quantity += main->next->quantity;\n            main->next = main->next->next;\n        } // else did not find duplicate\n        main = main->next;\n        count++;\n    }\n\n    return EXIT_SUCCESS;\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4448, "matched_exact": 887, "matched_approx": 912, "matched_human": 3816, "matched_total": 10063, "suggestions_matched": 5, "suggestions_approx": 5, "suggestions_total": 18, "suggestions_with_funcs": 13}}
{"uuid": "a80d5d0f-724e-4a28-8af1-02ca84993567", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_item_to_string", "extra_info": null}, {"label": "CodexApproximate", "text": "if (head == NULL) {\n        return EXIT_FAILURE;\n    } else {\n        sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    }\n    re", "function": "list_item_to_string", "extra_info": {"ts": "2022-05-01T04:59:52.011Z", "text": "if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->product_name, head->price);\n    return EXIT_SUCC", "distance": 0.20121951219512196}}, {"label": "Human", "text": "turn EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    if ", "function": "list_print", "extra_info": null}, {"label": "Codex", "text": "(head == NULL) {\n        return EXIT_FAILURE;\n    } else {\n        node *cur = head;\n        int pos = 1;\n        while (cur != NULL) {\n            printf(\"%d: %s\\n\", pos, list_item_to", "function": "list_print", "extra_info": {"ts": "2022-05-02T02:08:05.955Z", "text": "(head == NULL) {\n        return EXIT_FAILURE;\n    } else {\n        node *cur = head;\n        int pos = 1;\n        while (cur != NULL) {\n            printf(\"%d: %s\\n\", pos, list_item_to"}}, {"label": "Human", "text": "_string(cur, cur->item_name));\n            cur = cur->next;\n            pos++;\n        }\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if (pos<1) ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "{\n        return EXIT_FAILURE;\n    }\n    if (*head == NULL) {\n        node *new_node = malloc(sizeof(node));\n        if (new_node == NULL) {\n            return EXIT_FAILURE;\n        }\n", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-02T02:04:26.641Z", "text": "{\n        return EXIT_FAILURE;\n    }\n    if (*head == NULL) {\n        node *new_node = malloc(sizeof(node));\n        if (new_node == NULL) {\n            return EXIT_FAILURE;\n        }\n"}}, {"label": "Human", "text": "       ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": " new_node->item_name = item_name;\n        new_node->price = price;\n        new_node->quantity = quantity;\n        new_node->next = NULL;\n        *head = new_node;\n        return EXIT_", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-02T02:02:29.318Z", "text": " tmp->item_name = item_name;\n        tmp->price = price;\n        tmp->quantity = quantity;\n        return EXIT_SUCCESS;\n    }\n\n    node *tmp = *head;\n    int i = 1;\n    while (i < pos", "distance": 0.453551912568306}}, {"label": "Human", "text": "SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "    }\n    node *curr = *head;\n    node *prev = NULL;\n    for (unsigned int i=1; i<pos; i++) {\n        if (curr == NULL) {\n            return EXIT_FAILURE;\n        }\n        prev", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-02T02:04:37.466Z", "text": "    }\n    node *curr = *head;\n    node *prev = NULL;\n    for (unsigned int i=1; i<pos; i++) {\n        if (curr == NULL) {\n            return EXIT_FAILURE;\n        }\n        prev"}}, {"label": "Human", "text": " = curr;\n        curr = curr->next;\n    }\n    node *new_node = malloc(sizeof(node));\n    if (new_node == NULL) {\n        return EXIT_FAILURE;\n    }\n    new_node->", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "item_name = item_name;\n    new_node->price = price;\n    new_node->quantity = quantity;\n    new_node->next = curr;\n    if (curr == *head) {\n        *head = new_node;\n    } else", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-02T02:04:47.557Z", "text": "item_name = item_name;\n    new_node->price = price;\n    new_node->quantity = quantity;\n    new_node->next = curr;\n    if (curr == *head) {\n        *head = new_node;\n    } else"}}, {"label": "Human", "text": " {\n        prev->next = new_node;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if (pos<1) {\n        return EXIT_FAILUR", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "E;\n    }\n    if (*head == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *curr = *head;\n    for (unsigned int i=1; i<pos; i++) {\n        if (curr == NU", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-02T02:31:23.834Z", "text": "IT_SUCCESS;\n    }\n    node *curr = *head;\n    node *prev1 = NULL;\n    node *prev2 = NULL;\n    for (unsigned int i=1; i<pos1; i++) {\n        if (curr == NULL", "distance": 0.4230769230769231}}, {"label": "Human", "text": "L", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "L) {\n            return EXIT_FAILURE;\n        }\n        curr = curr->next;\n    }\n    curr->item_name = item_name;\n    curr->price = price;\n    curr->quantity = quant", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-01T04:53:07.700Z", "text": "{\n        return EXIT_FAILURE;\n    }\n    node *to_add = (node *)malloc(sizeof(node));\n    to_add->item_name = item_name;\n    to_add->price = price;\n    to_add->quant", "distance": 0.46060606060606063}}, {"label": "Human", "text": "ity;\n    return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "if (pos<1) {\n        return EXIT_FAILURE;\n    }\n    if (*head == NULL) {\n        return EXIT_FAILURE;\n    }\n    if (pos == 1) {\n        node *curr = *head;\n       ", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-05-02T02:24:09.423Z", "text": "if (pos<1) {\n        return EXIT_FAILURE;\n    }\n    if (*head == NULL) {\n        return EXIT_FAILURE;\n    }\n    if (pos == 1) {\n        node *curr = *head;\n       "}}, {"label": "Human", "text": " *head = curr->next;\n        free(curr);\n        return EXIT_SUCCESS;\n    }\n    node *curr = *head;\n    node *prev = NULL;\n    for (unsigned int i=1; i<pos; i++) {", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "\n        if (curr == NULL) {\n            return EXIT_FAILURE;\n        }\n        prev = curr;\n        curr = curr->next;\n    }\n    prev->next = curr->next;\n    free(curr);\n   ", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-05-02T02:24:13.913Z", "text": "\n        if (curr == NULL) {\n            return EXIT_FAILURE;\n        }\n        prev = curr;\n        curr = curr->next;\n    }\n    prev->next = curr->next;\n    free(curr);\n   "}}, {"label": "Human", "text": " return EXIT_SUCCESS;\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    if (pos1 < 1 || pos2 < 1) {\n        return EXIT_FAILURE;\n    }\n    if (*head == NULL) {\n        return EXIT_FAILURE;\n    }\n    if (pos1 == pos2) {\n        return EXIT_SUCCESS;\n    }\n    node *curr = *head;", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "\n    for (unsigned int i=1; i<pos1; i++) {\n        if (curr == NULL) {\n            return EXIT_FAILURE;\n        }\n        curr = curr->next;\n    }\n    list_update_item_at_", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-02T02:34:24.070Z", "text": "\n    for (unsigned int i=1; i<pos2; i++) {\n        if (curr == NULL) {\n            return EXIT_FAILURE;\n        }\n        curr = curr->next;\n    }\n    list_update_item_at_", "distance": 0.005847953216374269}}, {"label": "Human", "text": "pos(head, curr->item_name, curr->price, curr->quantity, pos2);\n    node *curr2 = *head;\n    \n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "\n    for (unsigned int i=1; i<pos2; i++) {\n        if (curr2 == NULL) {\n            return EXIT_FAILURE;\n        }\n        curr2 = curr2->next;\n    }\n    list_update_item_", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-02T02:34:22.284Z", "text": "\n    for (unsigned int i=1; i<pos2; i++) {\n        if (curr == NULL) {\n            return EXIT_FAILURE;\n        }\n        curr = curr->next;\n    }\n    list_update_item_at_", "distance": 0.03508771929824561}}, {"label": "Human", "text": "at_pos(head, curr2->item_name, curr2->price, curr2->quantity, pos1);\n    return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_find_highest_price_item_position(node *head, in", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "CodexApproximate", "text": "t *pos) {\n    if (head == NULL) {\n        return EXIT_FAILURE;\n    } else {\n        node *cur = head;\n        int curr_pos  = 1 ; \n        int max = -1; \n        while (", "function": "list_find_highest_price_item_position", "extra_info": {"ts": "2022-05-02T02:29:06.678Z", "text": " {\n        if (curr2 == NULL) {\n            return EXIT_FAILURE;\n        }\n        prev2 = curr2;\n        curr2 = curr2->next;\n    }\n    if (pos1 == 1) {\n        *head =", "distance": 0.4260355029585799}}, {"label": "Human", "text": "cur != NULL) {\n            if (cur->price > max) {\n                max = cur->price; \n                pos = curr_pos; \n                }\n            cur = cur->next;\n            curr_pos++;\n        }\n    }\n    return EXIT_SUCCESS;\n    \n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_cost_sum(node *head, float *total){\n    \n        return EXIT_SUCCESS; \n\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    return EXIT_SUCCESS;\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    return EXIT_SUCCESS; \n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate \n\n    return EXIT_SUCCESS;\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 3285, "matched_exact": 1057, "matched_approx": 1179, "matched_human": 1581, "matched_total": 7102, "suggestions_matched": 6, "suggestions_approx": 7, "suggestions_total": 33, "suggestions_with_funcs": 27}}
{"uuid": "a974cab3-f095-4360-969e-9942edfdedc1", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    snprintf(str, MAX_ITEM_PRINT_LEN, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    \n    int count = 1;\n    while", "function": "list_print", "extra_info": null}, {"label": "CodexApproximate", "text": "(head != NULL){\n        char *str = (char *)malloc(MAX_ITEM_PRINT_LEN);\n        list_item_to_string(head, str);\n        printf(\"%d: %s\\n\", count, str);\n        count++;\n   ", "function": "list_print", "extra_info": {"ts": "2022-05-02T20:51:52.009Z", "text": "(head != NULL){\n        char str[MAX_ITEM_PRINT_LEN];\n        if (list_item_to_string(head, str) == EXIT_SUCCESS){\n            printf(\"%s\\n\", str);\n        }\n        else{\n", "distance": 0.4186046511627907}}, {"label": "Human", "text": "     head = head->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    // a", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "dd a new item (name, price, quantity) to the list, such that the added item is the last item\n    node *newNode = malloc(sizeof(node));\n    newNode->item_name = item_name;\n    newN", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-02T23:24:42.058Z", "text": "if (item_name == NULL || price == 0 || quantity == 0){\n        return EXIT_FAILURE;\n    }\n\n    node *new_node = malloc(sizeof(node));\n    new_node->item_name = item_name;\n    new_", "distance": 0.44692737430167595}}, {"label": "Human", "text": "ode->price = price;\n    newNode->quantity = quantity;\n    newNode->next = NULL;\n    if (*head == NULL)", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "{\n        *head = newNode;\n        return EXIT_SUCCESS;\n    }\n    else if (pos == 0){\n        newNode->next = *head;\n        *head = newNode;\n        return EXIT_SUCCESS", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-03T02:00:00.014Z", "text": "if (*head == NULL){\n        return EXIT_FAILURE;\n    }\n    else if (pos1 == 0){\n        return EXIT_FAILURE;\n    }\n    else if (pos2 == 0){\n        return EXIT_FAILURE;\n", "distance": 0.4378698224852071}}, {"label": "Codex", "text": ";\n    }\n    else{\n        node *temp = *head;\n        for (int i = 0; i < pos - 1; i++){\n            if (temp->next == NULL){\n                break;\n            }\n            temp = temp->next;\n        }", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-03T01:59:14.463Z", "text": ";\n    }\n    else{\n        node *temp = *head;\n        for (int i = 0; i < pos - 1; i++){\n            if (temp->next == NULL){\n                break;\n            }\n            temp = temp->next;\n        }"}}, {"label": "Human", "text": "\n        newNode->next = temp->next;\n        temp->next = newNode;\n        return EXIT_SUCCESS;\n    }\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if (pos == 0){\n        (*head)->item_name = item_name;\n        (*head)->price = price;\n        (*head)->quantity = quantity;\n        return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "    }\n    else{\n        node *temp = *head;\n        for (int i = 0; i < pos - 1; i++){\n            if (temp->next == NULL){\n                break;\n            }\n            temp = temp->next;\n        }\n       ", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-03T02:32:56.309Z", "text": "    }\n    else{\n        node *temp = *head;\n        for (int i = 0; i < pos - 1; i++){\n            if (temp->next == NULL){\n                break;\n            }\n            temp = temp->next;\n        }\n       "}}, {"label": "Human", "text": " temp->item_name = item_name;\n        temp->price = price;\n        temp->quantity = quantity;\n        return EXIT_SUCCESS;\n    }\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_remove_item_at_pos(node **head, int pos){\n    if (pos == 1", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "){\n        node *temp = *head;\n        *head = (*head)->next;\n        free(temp);\n        return EXIT_SUCCESS;\n    }\n    else{\n        node *temp = *head;\n        for (int i = 0; i", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-05-03T02:36:44.686Z", "text": "){\n        node *temp = *head;\n        *head = (*head)->next;\n        free(temp);\n        return EXIT_SUCCESS;\n    }\n    else{\n        node *temp = *head;\n        for (int i = 0; i"}}, {"label": "CodexApproximate", "text": " < pos - 1; i++){\n            if (temp->next == NULL){\n                break;\n            }\n            temp = temp->next;\n        }\n        node *temp2 = temp->next;\n        temp->next = temp2->next;\n        free(temp2);\n        return ", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-05-03T01:23:45.373Z", "text": " i++){\n            if (temp->next == NULL){\n                break;\n            }\n            temp = temp->next;\n        }\n        temp->item_name = item_name;\n        temp->price = price;\n        temp->quantity = quantity;\n        return", "distance": 0.2911392405063291}}, {"label": "Human", "text": "EXIT_SUCCESS;\n    }\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "    node *temp1 = *head;\n    node *temp2 = *head;\n    for (int i = 0; i < pos1 - 1; i++){\n        temp1 = temp1->next;\n    }\n    for (int i = 0; i < pos2 - 1; i++){\n        temp2 = temp2->next;\n    }\n    node *temp3 = t", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-03T02:00:08.628Z", "text": "; i++){\n            if (temp->next == NULL){\n                break;\n            }\n            temp = temp->next;\n        }\n        for (int i = 0; i < pos2 - 1; i++){\n            if (temp->next == NULL){\n               ", "distance": 0.4977168949771689}}, {"label": "Human", "text": "emp1->next;\n    temp1->next = temp2->next;\n    temp2->next = temp3;\n    return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_find_highest_price_item_position(node *head, int *pos) {\n    ", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Codex", "text": "node *temp = head;\n    int max = 0;\n    int count = 1;\n    while(temp != NULL){\n        if (temp->price > max){\n            max = temp->price;\n            *pos = count;\n        }\n        temp = temp->next", "function": "list_find_highest_price_item_position", "extra_info": {"ts": "2022-05-03T02:59:48.125Z", "text": "node *temp = head;\n    int max = 0;\n    int count = 1;\n    while(temp != NULL){\n        if (temp->price > max){\n            max = temp->price;\n            *pos = count;\n        }\n        temp = temp->next"}}, {"label": "Human", "text": ";\n        count++;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_cost_sum(node *head, float *total){\n    float sum = 0;\n    while(head != NULL){\n        sum = sum + (head->price * head->quantity);\n        head = head->next;\n    }\n    *total = sum;\n    return EXIT_SUCCESS;\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_save", "extra_info": null}, {"label": "CodexApproximate", "text": "FILE *f = fopen(filename, \"w\");\n    if (f == NULL){\n        return EXIT_FAILURE;\n    }\n    while(head != NULL){\n        fprintf(f, \"%s,%.2f,%d\\n\", head->item_name, he", "function": "list_save", "extra_info": {"ts": "2022-05-03T03:08:17.022Z", "text": "FILE *f = fopen(filename, \"r\");\n    if (f == NULL){\n        return EXIT_FAILURE;\n    }\n    char name[100];\n    float price;\n    int quantity;\n    while(fscanf(f, \"%s,", "distance": 0.39156626506024095}}, {"label": "Human", "text": "ad->price, head->quantity);\n        head = head->next;\n    }\n    fclose(f);\n    return EXIT_SUCCESS;\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_load", "extra_info": null}, {"label": "CodexApproximate", "text": "FILE *f = fopen(filename, \"r\");\n    if (f == NULL){\n        return EXIT_FAILURE;\n    }\n    char item_name[100];\n    float price;\n    int quantity;\n    int l =0;\n    wh", "function": "list_load", "extra_info": {"ts": "2022-05-03T03:10:50.224Z", "text": "FILE *f = fopen(filename, \"r\");\n    if (f == NULL){\n        return EXIT_FAILURE;\n    }\n    char item_name[100];\n    float price;\n    int quantity;\n    while(!feof(f)){", "distance": 0.09580838323353294}}, {"label": "Human", "text": "ile(!feof(f)){\n        fscanf(f, \"%[^,],%f,%d\\n\", item_name, &price, &quantity);\n        list_add_item_at_pos(head, item_name, price, quantity, l);\n        l+=1;\n    }\n    fclose(f);\n    return EXIT_SUCCESS;\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 2433, "matched_exact": 796, "matched_approx": 1309, "matched_human": 1553, "matched_total": 6091, "suggestions_matched": 4, "suggestions_approx": 7, "suggestions_total": 45, "suggestions_with_funcs": 41}}
{"uuid": "b59feaf2-4c48-4ec0-8d00-3428362914a7", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_item_to_string(node *head) {\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    if(head != NULL){\n        newLine = str(head->quantity) + \"*\" + str(head->item_name) + \" @ $\" + str(head->price) + \" ea\\n\";\n    } else {\n        newLine = \"\";\n    }\n    return newLine;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    int counter = 0;\n    while(head != NULL){\n        printf(\"%d: %s\\n\", counter, list_item_to_string(head));\n        head = head->next;\n        counter++;\n    }\n    return EXIT_SUCCESS; \n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    for(int i = 0; i < pos; i++){\n        *head = (*head)->next;\n    }\n    if(*head == NULL){\n        node", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": " * new_node = malloc(sizeof(node));\n        new_node->item_name = item_name;\n        new_node->price = price;\n        new_node->quantity = quantity;\n        new_node->next = NULL;\n        *head = new_node;\n        r", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-11T19:49:30.869Z", "text": " * new_node = malloc(sizeof(node));\n            new_node->item_name = item_name;\n            new_node->price = price;\n            new_node->quantity = quantity;\n            new_node->next = NULL;\n            *head =", "distance": 0.17674418604651163}}, {"label": "Human", "text": "eturn EXIT_SUCCESS;\n    } else", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": " {\n        node * new_node = malloc(sizeof(node));\n        new_node->item_name = item_name;\n        new_node->price = price;\n        new_node->quantity = quantity;\n        new_node->next = *head;", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-11T19:54:52.028Z", "text": " {\n        node * new_node = malloc(sizeof(node));\n        new_node->item_name = item_name;\n        new_node->price = price;\n        new_node->quantity = quantity;\n        new_node->next = *head;"}}, {"label": "Human", "text": "\n        return EXIT_SUCCESS;\n    }\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4624, "matched_exact": 195, "matched_approx": 215, "matched_human": 587, "matched_total": 5621, "suggestions_matched": 1, "suggestions_approx": 1, "suggestions_total": 4, "suggestions_with_funcs": 3}}
{"uuid": "be6fa0a5-e7ff-4ae0-b846-57d9385acd84", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL) {\n        return EXIT_SUCCESS;\n    }\n\n    sprintf(str, \"%d * %s @ %.2f ea\", head->quantity, head->item_name, head->price);\n\n    return EXIT_SUCCESS;\n}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "\n// print the entire list to an externally allocated string\n// This should be in the format of:\n// \"item_name item_name item_name ...\", where item_name is a string\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_to_string(node *head) {\n    if (head == NULL) {\n        return EXIT_SUCCESS;\n    }\n\n    while(head != NULL) {\n        printf(\"%s\", head->item_name);\n        head = head->next;\n        if(head != NULL) {\n            printf(\" \");\n        }\n    }\n\n    return EXIT_SUCCESS;\n", "function": "list_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    if(head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    unsigned int pos = 1;\n    while(head != NULL) {\n        printf(\"%d: %d * %s @ %.2f ea\\n\", pos, head->quantity, head->item_name, head->price);\n        head = head->next;\n        pos++;\n    }\n\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    unsigned int i = 1;\n    node *prev = NULL;\n    node *curr = *head;\n\n    if(pos == 0)\n        return EXIT_FAILURE;\n    \n\n    while(curr != NULL) {\n        if(i == pos) {\n            node newItem;\n            newItem.item_name = item_name;\n            newItem.price = price;\n            newItem.quantity = quantity;\n            newItem.next = curr;\n\n            if(prev == NULL) {\n                *head = &newItem;\n            } else {\n                prev->next = &newItem;\n            }\n\n            return EXIT_SUCCESS;\n        }\n        prev = curr;\n        curr = curr->next;\n        i++;\n    }\n\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "unsigned int i = 1;\n    node *prev = NULL;\n    node *curr = *head;\n\n    if(pos == 0)\n        return EXIT_FAILURE;\n\n    while(curr != NULL) {\n        if(i == pos) {\n           ", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-01T18:18:45.977Z", "text": "unsigned int i = 1;\n    node *prev = NULL;\n    node *curr = *head;\n\n    if(pos == 0)\n        return EXIT_FAILURE;\n\n    while(curr != NULL) {\n        if(i == pos) {\n           "}}, {"label": "Human", "text": " ", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "curr->item_name = item_name;\n            curr->price = price;\n            curr->quantity = quantity;\n\n            return EXIT_SUCCESS;\n        }\n        prev = curr;\n        curr = curr->next;\n        i", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-01T16:42:59.022Z", "text": "curr->item_name = item_name;\n            curr->price = price;\n            curr->quantity = quantity;\n\n            return EXIT_SUCCESS;\n        }\n        prev = curr;\n        curr = curr->next;\n        i"}}, {"label": "Human", "text": "++;\n    }\n\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_remove_item_at_pos(node **head, int pos) {\n    int i = 1;\n    node *prev = NULL;\n    node *curr = *head;\n\n    if(pos == 0)\n        return EXIT_FAILURE;\n\n    while(curr != NULL) {\n        if(i == pos) {\n            ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "// If prev is NULL, we are removing the head\n            if(prev == NULL) {\n                *head = curr->next;\n            } else {\n                prev->next = curr->next;\n            }\n\n            return EXIT_SUCCESS;\n        }\n", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-05-01T16:44:50.433Z", "text": "// If prev is NULL, we are removing the head\n            if(prev == NULL) {\n                *head = curr->next;\n            } else {\n                prev->next = curr->next;\n            }\n\n            return EXIT_SUCCESS;\n        }\n"}}, {"label": "Human", "text": "\n        prev = curr;\n        curr = curr->next;\n        i++;\n    }\n    \n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    node *prev1 = NULL;\n    node *curr1 = *head;\n\n    int i = 1;\n    while(curr1 != NULL) {\n        if(i == pos1) {\n            break;\n        }\n        prev1 = curr1;\n        curr1 = curr1->next;\n    }\n\n    node *prev2 = NULL;\n    node *curr2 = *head;\n\n    i = 1;\n    while(curr2 != NULL) {\n        if(i == pos2) {\n            break;\n        }\n        prev2 = curr2;\n        curr2 = curr2->next;", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Codex", "text": "\n    }\n\n    if(prev1 == NULL) {\n        *head = curr2;\n    } else {\n        prev1->next = curr2;\n    }\n\n    if(prev2 == NULL) {\n        *head = curr1;\n    }", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-01T18:27:08.479Z", "text": "\n    }\n\n    if(prev1 == NULL) {\n        *head = curr2;\n    } else {\n        prev1->next = curr2;\n    }\n\n    if(prev2 == NULL) {\n        *head = curr1;\n    }"}}, {"label": "Codex", "text": " else {\n        prev2->next = curr1;\n    }\n\n    if(curr1->next == curr2) {\n        curr1->next = curr2->next;\n        curr2->next = curr1;\n    } else if(", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-01T18:27:23.393Z", "text": " else {\n        prev2->next = curr1;\n    }\n\n    if(curr1->next == curr2) {\n        curr1->next = curr2->next;\n        curr2->next = curr1;\n    } else if("}}, {"label": "Human", "text": "curr2->next == curr1) {\n        curr2->next = curr1->next;\n        curr1->next = curr2;\n    }\n\n    return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Codex", "text": "if(head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    int highestPrice = 0;\n    int highestPricePos = 0;\n    unsigned int i = 1;\n\n    while(head != NULL) {\n        if(head->price > highest", "function": "list_find_highest_price_item_position", "extra_info": {"ts": "2022-05-01T16:48:12.476Z", "text": "if(head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    int highestPrice = 0;\n    int highestPricePos = 0;\n    unsigned int i = 1;\n\n    while(head != NULL) {\n        if(head->price > highest"}}, {"label": "Human", "text": "Price) {\n            highestPrice = head->price;\n            highestPricePos = i;\n        }\n        head = head->next;\n        i++;\n    }\n\n    *pos = highestPricePos;\n\n    return EXIT_SUCCESS;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "    if(head == NULL) {\n        return EXIT_FAILURE", "function": "list_cost_sum", "extra_info": null}, {"label": "CodexApproximate", "text": ";\n    }\n\n    *total = 0;\n    while(head != NULL) {\n        *total += (head->quantity * head->price);\n        head = head->next;\n    }\n\n    return EXIT_SUCCESS", "function": "list_cost_sum", "extra_info": {"ts": "2022-05-01T05:04:37.056Z", "text": "printf(\"%d: %d * %s @ %.2f ea\\n\", list_get_pos(head), head->quantity, head->item_name, head->price);\n        head = head->next;\n    }\n\n    return EXIT_SUCCESS", "distance": 0.4620253164556962}}, {"label": "Human", "text": ";\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    FILE *f = fopen(filename, \"w\");\n    if(f == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    while(head != NULL) {\n        fprintf(f, \"%s,%.2f,%d\\n\", head->item_name, head->price, head->quantity);\n\n        head = head->next;\n    }\n    \n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    FILE *f = fopen(filename, \"r\");\n    if(f == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    \n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "    return EXIT_SUCCESS;\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 3378, "matched_exact": 1111, "matched_approx": 158, "matched_human": 2936, "matched_total": 7583, "suggestions_matched": 6, "suggestions_approx": 1, "suggestions_total": 14, "suggestions_with_funcs": 8}}
{"uuid": "c23b2615-700f-48f2-b33d-3433d1c25bb6", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *curr = head;\n    int pos = 1;\n    while (curr != NULL) {\n        printf(\"%d: \", pos);\n        char ", "function": "list_print", "extra_info": null}, {"label": "Codex", "text": "str[MAX_ITEM_PRINT_LEN];\n        list_item_to_string(curr, str);\n        printf(\"%s\\n\", str);\n        curr = curr->next;\n        pos++;\n    }\n    return EXIT_SUCC", "function": "list_print", "extra_info": {"ts": "2022-05-01T23:13:28.133Z", "text": "str[MAX_ITEM_PRINT_LEN];\n        list_item_to_string(curr, str);\n        printf(\"%s\\n\", str);\n        curr = curr->next;\n        pos++;\n    }\n    return EXIT_SUCC"}}, {"label": "Human", "text": "ESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    node *curr = *head;\n    if (curr == NULL && pos == ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "1) {\n        curr = malloc(sizeof(node));\n        curr->item_name = item_name;\n        curr->price = price;\n        curr->quantity = quantity;\n        curr->next = NULL;\n        *head = curr", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-01T23:25:47.305Z", "text": "1) {\n        curr = malloc(sizeof(node));\n        curr->item_name = item_name;\n        curr->price = price;\n        curr->quantity = quantity;\n        curr->next = NULL;\n        *head = curr"}}, {"label": "Human", "text": ";\n        return EXIT_SUCCESS;\n ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "   }\n    if (curr == NULL && pos != 1) {\n        return EXIT_FAILURE;\n    }\n    if (pos == 1) {\n        *head = malloc(sizeof(node));\n        if (*head == NULL) {\n            ret", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-01T23:17:44.291Z", "text": "curr = *head;\n    if (curr == NULL) {\n        return EXIT_FAILURE;\n    }\n    if (pos == 1) {\n        *head = malloc(sizeof(node));\n        if (*head == NULL) {\n            printf", "distance": 0.15168539325842698}}, {"label": "Human", "text": "urn EXIT_FAILURE;\n        }\n        (*head)->quantity = quantity;\n        (*head)->price = price;\n        (*head)->item_name = item_name;\n        (*head", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": ")->next = curr;\n        return EXIT_SUCCESS;\n    }\n    int pos_count = 1;\n    while (pos_count < pos - 1) {\n        if (curr->next == NULL) {\n            return EXIT_FAILURE", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-01T23:18:00.585Z", "text": ")->next = curr;\n        return EXIT_SUCCESS;\n    }\n    int pos_count = 1;\n    while (pos_count < pos - 1) {\n        if (curr->next == NULL) {\n            return EXIT_FAILURE"}}, {"label": "Human", "text": ";\n        }\n        curr = curr->next;\n        pos_count++;\n    }\n    node *new_no", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "de = malloc(sizeof(node));\n    if (new_node == NULL) {\n        return EXIT_FAILURE;\n    }\n    new_node->quantity = quantity;\n    new_node->price = price;\n    new_node->item_name = item_name;\n    new_node->", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-01T23:17:51.765Z", "text": "(\"add item at pos: malloc failed\\n\");\n            return EXIT_FAILURE;\n        }\n        (*head)->quantity = quantity;\n        (*head)->price = price;\n        (*head)->item_name = item_name;\n        (*head", "distance": 0.43902439024390244}}, {"label": "Human", "text": "next = curr->next;\n    curr->next = new_node;\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    node *curr = *head;\n    if (curr == NULL){\n        ", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "return EXIT_FAILURE;\n    }\n    if (pos == 1) {\n        curr->quantity = quantity;\n        curr->price = price;\n        curr->item_name = item_name;\n        return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-01T23:26:03.399Z", "text": "return EXIT_FAILURE;\n    }\n    if (pos == 1) {\n        curr->quantity = quantity;\n        curr->price = price;\n        curr->item_name = item_name;\n        return EXIT_SUCCESS;\n"}}, {"label": "Codex", "text": "    }\n    int pos_count = 1;\n    while (pos_count < pos - 1) {\n        if (curr->next == NULL) {\n            return EXIT_FAILURE;\n        }\n        curr = curr->next;\n        pos_", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-01T23:26:08.308Z", "text": "    }\n    int pos_count = 1;\n    while (pos_count < pos - 1) {\n        if (curr->next == NULL) {\n            return EXIT_FAILURE;\n        }\n        curr = curr->next;\n        pos_"}}, {"label": "Human", "text": "count++;\n    }\n    curr->quantity = quantity;\n    curr->price = price;\n    curr->item_name = item_name;\n    return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    node* cur=*head;\n    ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "if (cur == NULL){\n        return EXIT_FAILURE;\n    }\n    if (pos == 1){\n        *head = cur->next;\n        free(cur);\n        return EXIT_SUCCESS;\n    }\n    int pos_count = 1", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-05-01T23:27:22.701Z", "text": "if (cur == NULL){\n        return EXIT_FAILURE;\n    }\n    if (pos == 1){\n        *head = cur->next;\n        free(cur);\n        return EXIT_SUCCESS;\n    }\n    int pos_count = 1"}}, {"label": "Codex", "text": ";\n    while (pos_count < pos - 1) {\n        if (cur->next == NULL) {\n            return EXIT_FAILURE;\n        }\n        cur = cur->next;\n        pos_count++;\n    }\n    node* new_node =", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-05-01T23:27:31.979Z", "text": ";\n    while (pos_count < pos - 1) {\n        if (cur->next == NULL) {\n            return EXIT_FAILURE;\n        }\n        cur = cur->next;\n        pos_count++;\n    }\n    node* new_node ="}}, {"label": "Human", "text": " cur->next;\n    cur->next = new_node->next;\n    free(new_node);\n    return EXIT_SUCCESS;\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    if (*head == NULL){\n        return EXIT_FAILURE;\n    }\n    if (pos1 > pos2){", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "\n        int temp = pos1;\n        pos1 = pos2;\n        pos2 = temp;\n    }\n    node *curr1 = *head;\n    if (pos1 == pos2) {\n        return EXIT_SUCCESS;\n    }\n", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-01T23:31:05.733Z", "text": "int temp = pos1;\n        pos1 = pos2;\n        pos2 = temp;\n    }\n    node *curr = *head;\n    if (pos1 == 1 && pos2 == 1) {\n        return EXIT_SUCCESS;\n    }\n", "distance": 0.12658227848101267}}, {"label": "Human", "text": "    int pos_count=1;\n    node *curr2 = *head;\n    while(pos_count < pos1){\n        if (curr1 == NULL){\n            return EXIT_FAILURE;\n        }\n        c", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "urr1=curr1->next;\n        curr2=curr2->next;\n        pos_count++;\n    }\n    while(pos_count < pos2){\n        if (curr2 == NULL){\n            return EXIT_FAILURE;\n        }\n     ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-01T23:25:39.339Z", "text": "ity = quantity;\n        curr->next = NULL;\n        *head = curr;\n        return EXIT_SUCCESS;\n    }\n    if (curr == NULL && pos != 1) {\n        return EXIT_FAILURE;\n    }\n    if", "distance": 0.480225988700565}}, {"label": "Human", "text": "   curr2=curr2->next;\n        pos_count++;\n    }\n    node *temp = curr1->item_name;\n    curr1->item_name = curr2->item_name;\n    curr2->item_name = temp;\n    int tempval = curr1->quantity;\n    curr1->quantity = curr2->quantity;\n    curr2->quantity = tempval;\n    float tempfloat=curr1->price;\n    curr1->price = curr2->price;\n    curr2->price = tempfloat;\n    return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL){\n       return EXIT_FAILURE; \n    }\n    float tempmax = head->price;\n    int maxid = 1;\n    node *curr=head;\n    int index=1;\n    for (curr=head; curr!=NULL; curr=curr->next){\n        if (curr->price > tempmax){\n            tempmax=curr->price;\n            maxid=index;\n        }\n        index++;\n    }\n    *pos=maxid;\n    return EXIT_SUCCESS;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL)\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "    node *curr;\n    *total = 0;\n    for (curr=head; curr; curr=curr->next){\n        *total += curr->price * curr->quantity;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    if (!head || !filename){\n        return EXIT_FAILURE;\n    }\n    FILE * fp = NULL;\n    fp = fopen(filename, \"w+\");\n    if (fp ==NULL){\n        return EXIT_FAILURE;\n    }\n    node *curr;\n    for (curr=head; curr; curr=curr->next){\n        fprintf(fp, \"%s,%.2f,%d\\n\", curr->item_name, curr->price, curr->quantity);\n    }\n    fclose(fp);\n    return EXIT_SUCCESS;\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    if (!head || !filename)\n    {\n        return EXIT_FAILURE;\n    }\n    FILE *fp = fopen(filename, \"r\");\n    char line[MAX_ITEM_PRINT_LEN];\n    char itemname[MAX_ITEM_PRINT_LEN];\n    float price=0;\n    int quantity=0;\n    int count=1;\n    list_add_item_at_pos(head,\"apple\",0.80,2,1);\n    list_add_item_at_pos(head,\"banana\",0.50,3,2);\n    list_add_item_at_pos(head,\"cheese\",10.59,1,3);\n    return EXIT_SUCCESS;\n\n    \n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "    list_update_item_at_pos(head,\"item1\",1.0,11,1);\n    list_remove_item_at_pos(head, 2);\n    return EXIT_SUCCESS;\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4472, "matched_exact": 1239, "matched_approx": 718, "matched_human": 3088, "matched_total": 9517, "suggestions_matched": 7, "suggestions_approx": 4, "suggestions_total": 25, "suggestions_with_funcs": 18}}
{"uuid": "dac37585-9926-4e20-8ac1-40addd42f1a8", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// ", "function": null, "extra_info": null}, {"label": "Codex", "text": "implement a ", "function": null, "extra_info": {"ts": "2022-04-11T18:57:48.459Z", "text": "implement a "}}, {"label": "Human", "text": "node struct with item, quantity, price\n// struct node {\n//   char* item;\n//   int quantity;\n//   int price;\n//   struct node *next;\n// };\n\n", "function": null, "extra_info": null}, {"label": "Template", "text": "// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    if ", "function": "list_item_to_string", "extra_info": null}, {"label": "CodexApproximate", "text": "(head == NULL) {\n        return EXIT_FAILURE;\n    }\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUCCE", "function": "list_item_to_string", "extra_info": {"ts": "2022-04-11T18:55:37.029Z", "text": "(head == NULL) {\n        return EXIT_FAILURE;\n    }\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item, head->price);\n    return EXIT_SUCCESS;\n}", "distance": 0.06289308176100629}}, {"label": "Human", "text": "SS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n", "function": "list_print", "extra_info": null}, {"label": "Codex", "text": "    // TODO: Implement this ", "function": "list_print", "extra_info": {"ts": "2022-04-11T19:21:52.870Z", "text": "    // TODO: Implement this "}}, {"label": "Human", "text": "function,\n    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *cur = head;\n    int pos = 1;\n    char *str = malloc(MAX_ITEM_PRINT_LEN * sizeof(char));\n    while (cur != NULL) {\n        list_item_to_string(cur, str);\n        printf(\"%d: %s\\n\", pos, str);\n        pos++;\n        free(str);\n        cur = cur->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    // if the head is NULL, add the node at the first position\n    ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "if (*head == NULL) {\n        node *new = malloc(sizeof(node));\n        new->item_name = item_name;\n        new->price = price;\n        new->quantity = quantity;\n        new->next = NULL;\n        *head =", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-11T19:26:54.316Z", "text": "if (*head == NULL) {\n        node *new = malloc(sizeof(node));\n        new->item_name = item_name;\n        new->price = price;\n        new->quantity = quantity;\n        new->next = NULL;\n        *head ="}}, {"label": "Human", "text": " new;\n        return EXIT_SUCCESS;\n    }\n\n    // if the head is not NULL, find the node at the first position and add the node at the first position\n    node *cur = *head;\n    int i = 1;\n    while (cur != NULL && i < pos - 1) {\n        cur = cur->next;\n        i++;\n    }\n    // if the i is less than pos, return ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "failure\n    if (i < pos - 1) {\n        return EXIT_FAILURE;\n    }\n    // else, add the node at the first position\n    node *new_node = malloc(sizeof(node));\n    new_node->item_name = item", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-11T19:13:33.487Z", "text": "failure\n    if (i < pos - 1) {\n        return EXIT_FAILURE;\n    }\n    // else, add the node at the first position\n    node *new_node = malloc(sizeof(node));\n    new_node->item_name = item"}}, {"label": "Human", "text": "_name;\n    new_node->price = price;\n    new_node->quantity = quantity;\n    new_node->next = cur->next;\n    cur->next = new_node;\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    // if the list is empty, reutrn failure\n    if (*head == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *cur = *head;\n    int i = 1;\n    while (cur != NULL && i < pos) {\n        cur = cur->next;\n        i++;\n    ", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "}\n    if (i < pos) {\n        return EXIT_FAILURE;\n    }\n    cur->price = price;\n    cur->quantity = quantity;\n    // free(cur->item_name);\n    cur->item_name = strdup(ite", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-11T19:46:25.193Z", "text": "}\n    if (i < pos - 1) {\n        return EXIT_FAILURE;\n    }\n    cur->price = price;\n    cur->quantity = quantity;\n    free(cur->item_name);\n    cur->item_name = item_name", "distance": 0.08823529411764706}}, {"label": "Human", "text": "m_name);\n    // cur->item_name = item_name;\n    return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    // if the list is empty, return fail\n    if (*head == NULL) {\n        return EXIT_FAILURE;\n    }\n    // if the node to be removed is at position 1, set the head->next to be the head\n    ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "if (pos == 1) {\n        node *new_head = (*head)->next;\n        free(*head);\n        *head = new_head;\n        return EXIT_SUCCESS;\n    }\n    // else, find the node that is at position pos-", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-11T20:17:35.857Z", "text": "if (pos == 1) {\n        node *new_head = (*head)->next;\n        free(*head);\n        *head = new_head;\n        return EXIT_SUCCESS;\n    }\n    // else, find the node that is at position pos-"}}, {"label": "Human", "text": "\n    node *cur = *head;\n    int i = 1;\n    while (cur != NULL && i < pos) {\n        cur = cur->next;\n        i++;\n    }\n    ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "if (i < pos) {\n        return EXIT_FAILURE;\n    }\n    node *prev = *head;\n    while (prev->next != cur) {\n        prev = prev->next;\n    }\n    prev->next = cur->next;\n   ", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-11T20:09:21.931Z", "text": "if (i < pos) {\n        return EXIT_FAILURE;\n    }\n    node *prev = *head;\n    while (prev->next != cur) {\n        prev = prev->next;\n    }\n    prev->next = cur->next;\n   "}}, {"label": "Human", "text": " // free the curr node\n    // free(cur);\n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_SUCCESS;\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    // if the list is empty, return fail\n    ", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Codex", "text": "if (*head == NULL) {\n        return EXIT_FAILURE;\n    }\n    // if the pos1 or pos2 is out of range, return fail\n    if (pos1 <= 0 || pos2 <= 0) {\n        return EXIT_FAILURE;\n", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-11T20:18:22.332Z", "text": "if (*head == NULL) {\n        return EXIT_FAILURE;\n    }\n    // if the pos1 or pos2 is out of range, return fail\n    if (pos1 <= 0 || pos2 <= 0) {\n        return EXIT_FAILURE;\n"}}, {"label": "Codex", "text": "    }\n    // if the pos1 and pos2 are the same, return success\n    if (pos1 == pos2) {\n        return EXIT_SUCCESS;\n    }\n    // if the pos1 is the head, swap it with the pos2\n    if (", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-11T20:18:29.933Z", "text": "    }\n    // if the pos1 and pos2 are the same, return success\n    if (pos1 == pos2) {\n        return EXIT_SUCCESS;\n    }\n    // if the pos1 is the head, swap it with the pos2\n    if ("}}, {"label": "Human", "text": "pos1 == 1) {\n        node *old_head = *head;\n        node *new_head = *head;\n        int i = 1;\n        while (new_head != NULL && i < pos2) {\n            new_head = new_head->next;\n            i++;\n        }\n        // swap new head and old head\n        node *temp = old_head->next;\n        old_head->next = new_head->next;\n        new_head->next", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": " = temp;\n        *head = new_head;\n        return EXIT_SUCCESS;\n    }\n    // if the pos2 is the head, swap it with the pos1\n    if (pos2 == 1) {\n        node *old_head = *head;\n        node *new_head = *head;\n   ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-11T19:09:13.957Z", "text": " = NULL;\n        *head = new_node;\n        return EXIT_SUCCESS;\n    }\n\n    // if the head is not NULL, find the node at the first position and add the node at the first position\n    node *cur = *head;\n    int i =", "distance": 0.46226415094339623}}, {"label": "Human", "text": "     int i = 1;\n        while (new_head != NULL && i < pos1) {\n            new_head = new_head->next;\n            i++;\n        }\n        // swap new head and old head\n        node *temp = old_head->next;\n        old_head->next = new_head->next;\n        new_head->next = temp;\n        *head = new_head;\n        return EXIT_SUCCESS;\n    }\n    // else swap the two nodes\n    node *nod", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "e1 = *head;\n    node *node2 = *head;\n    int i = 1;\n    while (node1 != NULL && i < pos1) {\n        node1 = node1->next;\n        i++;\n    }\n    // find the previous no", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-11T20:11:45.381Z", "text": "->next;\n    node *prev = *head;\n    int i = 1;\n    while (cur != NULL && i < pos) {\n        prev = cur;\n        cur = cur->next;\n        i++;\n    }\n    if (i < pos) {\n", "distance": 0.3652694610778443}}, {"label": "Human", "text": "de of node 1\n    // for some reason the model is not working for me here\n    i = 1;\n    node *temp = node1->next;\n    while (node2 != NULL && i < pos2) {\n        node2 = node2->next;\n        i++;\n    }\n    // find the previous node of node 2\n\n    node1->next = node2->next;\n    // connect previous nodes to node 1 and 2\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "    // if the list is empty, return fail\n    if \n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4220, "matched_exact": 1147, "matched_approx": 708, "matched_human": 2919, "matched_total": 8994, "suggestions_matched": 8, "suggestions_approx": 4, "suggestions_total": 19, "suggestions_with_funcs": 10}}
{"uuid": "dc47e379-a3ba-464c-aa89-69374080111a", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n\n    // char output[] = itoa(head->quantity) + \" * \" + head->item_name + \" @ \" + \"$\" + printf(\"%.2f\", head->price) + \" ea\";\n    // char output[100] = quantityStr + \" * \" + head->item_name;\n    // char output[100] = strcat(quantityStr, \" \");\n    // str = strcat(quantityStr, \" \");\n\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    node *curr = head;\n    int pos = 1;\n    while (curr != NULL) {\n      char itemAsString[100];\n      list_item_to_string(curr, itemAsString);\n      printf(\"%d: %s\\n\", pos, itemAsString);\n      curr = curr->next;\n      pos += 1;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n", "function": null, "extra_info": null}, {"label": "Human", "text": "// 1: 3 * banana @ $1.00 e\n", "function": null, "extra_info": null}, {"label": "Template", "text": "// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    node* newNode = (node*) malloc(sizeof(node));\n    newNode->item_name = item_name;\n    newNode->price = price;\n    newNode->quantity = quantity;\n    newNode->next = NULL;\n\n    if(*head == NULL) {\n        *head = newNode;\n        return EXIT_SUCCESS;\n    } else if (pos == 0) {\n        newNode->next = *head;\n        *head = newNode;\n        return EXIT_SUCCESS;\n    } else {\n        node* prev = NULL;\n        node* curr = *head;\n        while (pos-1 > 0) {\n            prev = curr;\n            curr = curr->next;\n            pos--;\n        }\n        prev->next = newNode;\n        newNode->next = curr;\n        return EXIT_SUCCESS;\n    }\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "\n    node* curr = *head;\n    while (pos-1 > 0) {\n        curr = curr->next;\n        pos--;\n    }\n    curr->item_name = item_name;\n    curr->price = price;\n    curr->quantity = quantity;\n   ", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-12T20:31:34.985Z", "text": " else {\n        node* curr = *head;\n        while (pos-1 > 0) {\n            curr = curr->next;\n            pos--;\n        }\n        newNode->next = curr->next;\n        curr->next = newNode;", "distance": 0.43915343915343913}}, {"label": "Human", "text": " \n    return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n    if(*head == NULL) {\n        return EXIT_SUCCESS;\n    } else if (pos == 1) {\n        *head = (*head)", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "->next;\n        return EXIT_SUCCESS;\n    } else {\n        node* prev = NULL;\n        node* curr = *head;\n        while (pos-1 > 0) {\n            prev = curr;\n            curr = curr->next", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-13T09:34:49.756Z", "text": "->next;\n        return EXIT_SUCCESS;\n    } else {\n        node* prev = NULL;\n        node* curr = *head;\n        while (pos-1 > 0) {\n            prev = curr;\n            curr = curr->next"}}, {"label": "Human", "text": ";\n            pos--;\n        }\n        prev->next = curr->next;\n        return EXIT_SUCCESS;\n    }\n\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "\n    // find node at pos1, find node at pos2\n    // swap the prev node to point to correct after swap\n    // swap the node's next to appropriate node after swap\n\n    node* pos1Prev;\n    node* pos1Curr = *head;\n    node* pos1Next;\n    while (pos1-1 > 0) {\n        pos1Prev = pos1Curr;\n        pos1Curr = pos1Curr->next;\n        pos1--;\n    }\n\n    node* pos2Prev;\n    node* pos2Curr = *head;\n    node* pos2Next;\n    while (pos2-1 > 0) {\n        pos2Prev = pos2Curr;\n        pos2Curr = pos2Curr->next;\n        pos2--;\n    }\n\n    if (*pos1Prev != NULL) {\n        pos1Prev->next = pos2Curr;\n    } else {\n        *head = pos2Curr;\n    }\n    pos2Curr->next = pos1Next;\n\n    pos2Prev->next = pos1Curr;\n    pos1Curr->next = pos2Next;\n\n    return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "\n    node* curr = *head;\n    while (curr != NULL) {\n      char itemAsString[100];\n      list_item_to_string(curr, itemAsString);\n      printf(\"%d: %s\\n\", pos, itemAsString);\n      curr = curr->next;\n      pos += 1;\n    }\n\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "\n    node* curr = *head;\n    while (curr != NULL) {\n      float price = curr->price;\n      *total += price;\n      curr = curr->next;\n    }\n\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    FILE *fptr = fopen(filename, \"w\");\n\n    node* curr = *head;\n    while (curr != NULL) {\n      fprintf(fptr,\"%s,%f,%d\\n\", curr->item_name, curr-> price, curr->quantity);\n      curr = curr->next;\n    }\n\n    fclose(fptr);\n    return EXIT_SUCCESS;\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    FILE *fptr = fopen(filename, \"r\");\n\n    node* curr = *head;\n    while (curr != NULL) {\n      curr = curr->next;\n    }\n\n    char * line = NULL;\n    size_t len = 0;\n    ssize_t read;\n    while ((read = getline(&line, &len, fptr)) != -1) {\n      char delim[] = \",\";\n      char *ptr = strtok(line, delim);\n      // get three values, create new node, add to back of head\n    }\n\n    fclose(fptr);\n    return EXIT_SUCCESS;\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "\n    // loop over the head note, create map of frequencies\n\n    return EXIT_SUCCESS;\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4520, "matched_exact": 187, "matched_approx": 189, "matched_human": 3419, "matched_total": 8315, "suggestions_matched": 1, "suggestions_approx": 1, "suggestions_total": 3, "suggestions_with_funcs": 2}}
{"uuid": "ddac8637-a99c-458d-bff5-916acb92e259", "parts": [{"label": "Template", "text": "#include <stdio.h> \n", "function": null, "extra_info": null}, {"label": "Human", "text": "#include <stdlib.h>\n", "function": null, "extra_info": null}, {"label": "Template", "text": "#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    if(head == NULL){\n        return EXIT_FAILURE;\n    }\n    else{\n        sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    }\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    if(head == NULL){\n        return EXIT_FAILURE;\n    }\n    int pos = 1;\n    while(head != NULL){\n        printf(\"%d: %d * %s @ $%.2f ea\\n\", pos, head->quantity, head->item_name, head->price);\n        pos++;\n        head = head->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if(*head == NULL || pos > sizeof(*head)){\n        return EXIT_FAILURE;\n    }\n    int currPos = 0;\n    while(*head != NULL){\n        if(currPos =", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "= pos){\n            node *temp = (*head)->next;\n\n            node *new_node = malloc(sizeof(node));\n\n            new_node->item_name = item_name;\n            new_node->price = price;\n            new_no", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-29T17:45:08.689Z", "text": " != NULL){\n        if(pos == 0){\n            node *new_node = (node*)malloc(sizeof(node));\n            new_node->item_name = strdup(item_name);\n            new_node->price = price;\n            new_node", "distance": 0.2537313432835821}}, {"label": "Human", "text": "de->quantity = quantity;\n            new_node->next = temp;\n            (*head)->next = new_node;\n            return EXIT_SUCCESS;\n        }\n        currPos++;\n        *head = (*head)->next;\n    }\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if(*head == NULL){\n        return EXIT_FAILURE;\n    }\n    int currPos = 0;\n    w", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "hile(*head != NULL){\n        if(currPos == pos){\n            strcpy((*head)->item_name, item_name);\n            (*head)->price = price;\n            (*head)->quantity = quantity;\n            return EXIT_SUCC", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-29T16:49:59.463Z", "text": "*head != NULL){\n        if((*head)->pos == pos){\n            strcpy((*head)->item_name, item_name);\n            (*head)->price = price;\n            (*head)->quantity = quantity;\n            return EXIT_SUCC", "distance": 0.07281553398058252}}, {"label": "Human", "text": "ESS;\n        }\n        currPos++;\n        *head = (*head)->next;\n    }\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if(*head == NULL){\n        return EXIT_FAILURE;\n    }\n    int currPos = 0;\n    w", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "hile(*head != NULL){\n        if(currPos == pos){\n            node *node_to_remove = *head;\n            *head = (*head)->next;\n            free(node_to_remove);\n            return EXIT_SUCCESS;\n        }", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-29T16:51:18.323Z", "text": "*head != NULL){\n        if((*head)->pos == pos){\n            node *node_to_remove = *head;\n            *head = (*head)->next;\n            free(node_to_remove);\n            return EXIT_SUCCESS;\n        }", "distance": 0.07425742574257425}}, {"label": "Human", "text": "\n        currPos++;\n        *head = (*head)->next;\n    }\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    if (*head == NULL || pos1 == pos2 || pos1 > sizeof(*head) || pos2 > sizeof(*head))\n    {\n        return EXIT_FAILURE;\n    }\n    \n    node *item_to_swap1;\n    node *item_to_swap2;\n    node *temp;\n    int currPos = 0;\n    while(*head != NULL){\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "        if(currPos == pos1){\n            item_to_swap1 = *head;\n        }\n        else if(currPos == pos2){\n            item_to_swap2 = *head;\n        }\n        currPos++;\n  ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-30T03:40:45.977Z", "text": "(*head)->pos == pos1){\n            node *item_to_swap1 = *head;\n        }\n        if((*head)->pos == pos2){\n            node *item_to_swap2 = *head;\n        }\n        *head =", "distance": 0.3045977011494253}}, {"label": "Human", "text": "      *head = (*head)->next;\n    }\n    temp = item_to_swap1;\n    item_to_swap1 = item_to_swap2;\n    item_to_swap2 = temp;\n    return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "    if(head == NULL){\n        return EXIT_FAILURE;\n    }\n    int max = head->price;\n    while(head != NULL){\n        if(head->price > max){\n            max = head->price;\n        }\n        head = head->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "{ \n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "    if(head == NULL){\n        return EXIT_FAILURE;\n    }\n    while(head != NULL){\n        *total += (head->price * head->quantity);\n        head = head->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    if(head == NULL){\n        ", "function": "list_save", "extra_info": null}, {"label": "CodexApproximate", "text": "return EXIT_FAILURE;\n    }\n    FILE *file = fopen(filename, \"w\");\n    while(head != NULL){\n        fprintf(file, \"%s,$%.2f,%d\\n\", head->item_name, head->price, hea", "function": "list_save", "extra_info": {"ts": "2022-04-30T02:31:56.588Z", "text": "return EXIT_FAILURE;\n    }\n    FILE *file = fopen(filename, \"w\");\n    while(head != NULL){\n        fprintf(file, \"%s,%.2f,%d\\n\", head->item_name, head->price, head", "distance": 0.012269938650306749}}, {"label": "Human", "text": "d->quantity);\n        head = head->next;\n    }\n    fclose(file);\n    return EXIT_SUCCESS;\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    FILE *file = fopen(filename, \"r\");\n    if (file == NULL){\n        return EXIT_FAILURE;\n    }\n    char data[MAX_ITEM_PRINT_LEN];\n    char* token;\n    float num;\n    int quantity;\n    while(fgets(data, MAX_ITEM_PRINT_LEN, file) != NULL){\n        node *newNode = malloc(sizeof(node));\n        sscanf(data, \"%s,%f,%d\", ", "function": "list_load", "extra_info": null}, {"label": "CodexApproximate", "text": "newNode->item_name, &num, &quantity);\n        newNode->price = num;\n        newNode->quantity = quantity;\n        newNode->next = NULL;\n        if(*head == NULL){\n            *head = newNode;\n        }\n        e", "function": "list_load", "extra_info": {"ts": "2022-04-29T17:46:02.367Z", "text": "new_node->item_name = item_name;\n            new_node->price = price;\n            new_node->quantity = quantity;\n            new_node->pos = pos;\n            new_node->next = (*head)->next;\n            (*head)->", "distance": 0.44075829383886256}}, {"label": "Human", "text": "lse{\n            (*head)->next = newNode;\n        }\n    }\n    fclose(file);\n    return EXIT_SUCCESS;\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "    if(", "function": "list_deduplicate", "extra_info": null}, {"label": "CodexApproximate", "text": "*head == NULL){\n        return EXIT_FAILURE;\n    }\n    node *currNode = *head;\n    while(currNode != NULL){\n        node *itemPtr = currNode->next;\n        while(itemPtr != NULL){\n          ", "function": "list_deduplicate", "extra_info": {"ts": "2022-04-29T17:11:54.654Z", "text": "*head == NULL){\n        return EXIT_FAILURE;\n    }\n    node *current = *head;\n    for(int i = 0; i < pos1 - 1; i++){\n        current = current->next;\n        if(current == NULL){\n           ", "distance": 0.32105263157894737}}, {"label": "Human", "text": "  if(strcmp(currNode->item_name, itemPtr->item_name) == 0){\n                currNode->quantity += itemPtr->quantity;\n                currNode->next = itemPtr->next;\n                free(itemPtr);\n                itemPtr = currNode->next;\n            }\n            else{\n                itemPtr = itemPtr->next;\n            }\n        }\n        currNode = currNode->next;\n  ", "function": "list_deduplicate", "extra_info": null}, {"label": "CodexApproximate", "text": "  }\n    return EXIT_SUCCESS;\n", "function": "list_deduplicate", "extra_info": {"ts": "2022-04-29T17:36:37.601Z", "text": ");\n    return EXIT_SUCCESS;\n}", "distance": 0.13793103448275862}}, {"label": "Template", "text": "}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4209, "matched_exact": 0, "matched_approx": 1376, "matched_human": 2861, "matched_total": 8446, "suggestions_matched": 0, "suggestions_approx": 8, "suggestions_total": 24, "suggestions_with_funcs": 24}}
{"uuid": "e04ce3f6-46eb-465e-9828-5e768febf9be", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_item_to_string", "extra_info": null}, {"label": "Codex", "text": "// TODO: Implement this ", "function": "list_item_to_string", "extra_info": {"ts": "2022-04-24T04:33:15.649Z", "text": "// TODO: Implement this "}}, {"label": "Human", "text": "function\n    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    node* curr = head;\n    char* str;", "function": "list_print", "extra_info": null}, {"label": "CodexApproximate", "text": "\n    int i = 1;\n    while (curr != NULL) {\n        str = malloc(MAX_ITEM_PRINT_LEN);\n        list_item_to_string(curr, str);\n        printf(\"%d: %s\\n\", i, str)", "function": "list_print", "extra_info": {"ts": "2022-04-24T04:37:25.679Z", "text": "\n    int i = 1;\n    while (curr != NULL) {\n        str = malloc(MAX_ITEM_PRINT_LEN);\n        list_item_to_string(curr, str);\n        printf(str, i, curr->item_", "distance": 0.11320754716981132}}, {"label": "Human", "text": ";\n        free(str);\n        i++;\n        curr = curr->next;\n    }\n    return EXIT_SUCCESS;\n}\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "\n// Destroy the list. This should be a very simple operation, \n// so no error checks are required.\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_destroy(node **head) {\n    node* curr = *head;\n    while (*head != NULL) {\n        curr = *head;\n        *head = (*head)->next;\n        free(curr);\n    }\n    return EXIT_SUCCESS;\n}\n", "function": "list_destroy", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Human", "text": "node* get_item_at_pos(node** head, ", "function": "get_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "int pos) {\n    node* curr = *head;\n    int i = 1;\n    while (curr != NULL) {\n        if (i == pos) {\n            return curr;\n        }\n        curr = curr->next;\n        i++;\n", "function": "get_item_at_pos", "extra_info": {"ts": "2022-04-28T20:02:39.141Z", "text": "int pos) {\n    node* curr = *head;\n    int i = 1;\n    while (curr != NULL) {\n        if (i == pos) {\n            return curr;\n        }\n        curr = curr->next;\n        i++;\n"}}, {"label": "Human", "text": "    }\n    return NULL;\n", "function": "get_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "get_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    node *item = malloc(sizeof(node));\n    char* temp = malloc(sizeof(item_name));\n    strcpy(temp, item_name);\n    item->item_name = temp;\n    item->price = price;\n    item->quantity = quantity;\n\n    node *curr = *head;\n\n    if (pos == 1) {\n        item->next = *head;\n        *head = item;\n        return EXIT_SUCCESS;\n    }\n\n    for (unsigned int i = 1; i < pos-1; i++) {\n        if (curr == NULL) {\n            return EXIT_FAILURE;\n        }\n        curr = curr->next;\n    }\n\n    if (curr == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    item->next = curr->next;\n    curr->next = item;\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "    if (pos < 1 || head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    node *curr = *head;\n    int i = 1;\n    while (curr && i < pos - 1) {\n        curr = curr->next;\n   ", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-24T04:03:44.141Z", "text": " > 1) {\n        if (curr == NULL) {\n            return EXIT_FAILURE;\n        }\n        curr = curr->next;\n        pos--;\n    }\n\n    if (pos == 1) {\n        item.next = curr->", "distance": 0.4827586206896552}}, {"label": "Human", "text": " }\n\n    if (curr == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    node *item = malloc(sizeof(node));\n    char* temp = malloc(sizeof(item_name));\n    strcpy(temp, item_name);\n    curr->item_name = temp;\n    curr->price = price;\n    curr->quantity = quantity;\n    return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if(pos < 1 || head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    node *curr = *head;\n    node *prev = NULL;\n    int i = 1;\n    while (curr->next && i < pos) {\n     ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "   prev = curr;\n        curr = curr->next;\n        i++;\n    }\n\n    if (i < pos) {\n        return EXIT_FAILURE;\n    }\n\n    if (curr->next == NULL) {\n        if (prev =", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-04-28T18:18:16.177Z", "text": "URE;\n        }\n        curr = curr->next;\n    }\n\n    if (curr == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    curr->item_name = item_name;\n    curr->price = price;", "distance": 0.45180722891566266}}, {"label": "Human", "text": "= NULL) {\n            *head = NULL;\n        } else {\n            prev->next = NULL;\n        }\n        free(curr);\n    } else {\n        prev->next = curr->next;\n        free(curr);\n    }\n    return EXIT_SUCCESS;\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    node* item1 = get_item_at_pos(head, pos1)", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": ";\n    node* item2 = get_item_at_pos(head, pos2);\n    if (item1 == NULL || item2 == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    char* temp_item_name = item1->item_", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-28T20:03:26.588Z", "text": "\n    node* item2 = get_item_at_pos(pos2);\n    if (item1 == NULL || item2 == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    node* curr = *head;\n    node* prev = NULL;", "distance": 0.25301204819277107}}, {"label": "Human", "text": "name;", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Codex", "text": "\n    item1->item_name = item2->item_name;\n    item2->item_name = temp_item_name;\n\n    float temp_price = item1->price;\n    item1->price = item2->price;\n    item2->price = temp", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-28T20:05:27.830Z", "text": "\n    item1->item_name = item2->item_name;\n    item2->item_name = temp_item_name;\n\n    float temp_price = item1->price;\n    item1->price = item2->price;\n    item2->price = temp"}}, {"label": "Human", "text": "_price;\n\n    int temp_quantity = item1->quantity;\n    item1->quantity = item2->quantity;\n    item2->quantity = temp_quantity;\n\n    return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *curr = head;", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Codex", "text": "\n    int i = 1;\n    float highest = 0.0;\n    while (curr != NULL) {\n        if (curr->price > highest) {\n            *pos = i;\n            highest = curr->price;\n        }\n        curr = cur", "function": "list_find_highest_price_item_position", "extra_info": {"ts": "2022-04-28T20:06:17.027Z", "text": "\n    int i = 1;\n    float highest = 0.0;\n    while (curr != NULL) {\n        if (curr->price > highest) {\n            *pos = i;\n            highest = curr->price;\n        }\n        curr = cur"}}, {"label": "Human", "text": "r->next;\n        i++;\n    }\n\n    return EXIT_SUCCESS;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    node* curr = head;\n    *total = 0;\n\n    while (curr) {\n        *total += (curr->quantity * curr->price);\n        curr = curr->next;\n    }\n\n    return EXIT_SUCCESS;\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    FILE* fp;\n    fp = fopen(fil", "function": "list_save", "extra_info": null}, {"label": "CodexApproximate", "text": "ename, \"w+\");\n\n    if (!fp) {\n        return EXIT_FAILURE;\n    }\n\n    node* curr = head;\n\n    while (curr) {\n        fprintf(fp, \"%s,%.2f,%d\\n\",\n            curr->", "function": "list_save", "extra_info": {"ts": "2022-04-28T18:20:50.286Z", "text": "pos < 1 || head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    node *curr = *head;\n    int i = 1;\n    while (curr->next && i < pos - 1) {\n        curr = curr->", "distance": 0.4662576687116564}}, {"label": "Human", "text": "item_name, curr->price, curr->quantity);\n        curr = curr->next;\n    }\n\n    fclose(fp);\n    return EXIT_SUCCESS;\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "    FILE* fd;\n    fd = fopen(filename, \"r\");\n\n    if (!fd) {\n        return EXIT_FAILURE;\n    }\n\n    char* curr_line = malloc(2048*sizeof(char));\n    unsigned int i = 1;\n    unsigned int n = 0;\n    char* delim = \",\";\n    int c;\n    \n    while ((c = fgetc(fd)) != EOF) {\n        if (c == '\\n') {\n            curr_line[n] = '\\0';\n            n = 0;\n\n            char* arr[3];\n            arr[0] = strtok(curr_line, delim);\n            arr[1] = strtok(NULL, delim);\n            arr[2] = strtok(NULL, delim);\n\n            list_add_item_at_pos(head, arr[0],\n                atof(arr[1]), atoi(arr[2]), i++);\n            curr_line[0] = '\\0';\n        } else {\n            curr_line[n++] = (char)c;\n        }\n    }\n\n    free(curr_line);\n    fclose(fd);\n    return EXIT_SUCCESS;\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "    int capacity = 128;\n    char** item_names = malloc(capacity*sizeof(char", "function": "list_deduplicate", "extra_info": null}, {"label": "CodexApproximate", "text": "*));\n    \n    node *curr = *head;\n    int pos = 1;\n\n    while (curr) {\n        if (pos >= capacity) {\n            capacity *= 2;\n            item_names = realloc(item_names, ", "function": "list_deduplicate", "extra_info": {"ts": "2022-04-28T20:02:36.557Z", "text": ", int pos) {\n    node* curr = *head;\n    int i = 1;\n    while (curr != NULL) {\n        if (i == pos) {\n            return curr;\n        }\n        curr = curr->next;\n        i", "distance": 0.4482758620689655}}, {"label": "Human", "text": "capacity*sizeof(char*));\n        }\n\n        int found = 0;\n\n        for (unsigned int i = 0; i < pos - 1 && !found; ++i) {\n            if (strcmp(curr->item_name, item_names[i]) == 0) {\n                node* to_update = get_item_at_pos(head, i+1);\n                list_update_item_at_pos(head,\n                    to_update->item_name,\n                    to_update->price,\n                    to_update->quantity + curr->quantity,\n                    i+1);\n                \n                curr = curr->next;\n                list_remove_item_at_pos(head, pos);\n                found = 1;\n            }\n        }\n\n        if (!found) {\n            item_names[pos-1] = curr->item_name;\n            pos++;\n            curr = curr->next;\n        }\n    }\n\n    return EXIT_SUCCESS;\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 3359, "matched_exact": 565, "matched_approx": 1002, "matched_human": 4283, "matched_total": 9209, "suggestions_matched": 4, "suggestions_approx": 6, "suggestions_total": 19, "suggestions_with_funcs": 15}}
{"uuid": "ec83a892-5cfa-46bf-aab8-673aee747cb8", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    if ((head == NULL) || (str == NULL)){\n        return EXIT_FAILURE;\n    }\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    int i = 1;\n    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *current = head;", "function": "list_print", "extra_info": null}, {"label": "CodexApproximate", "text": "\n    while (current != NULL) {\n        char str[MAX_ITEM_PRINT_LEN];\n        if (list_item_to_string(current, str) == EXIT_FAILURE) {\n            return EXIT_FAILURE;\n   ", "function": "list_print", "extra_info": {"ts": "2022-04-30T07:02:58.200Z", "text": "\n    while (head != NULL) {\n        char item_print[MAX_ITEM_PRINT_LEN];\n        list_item_to_string(head, item_print);\n        printf(\"%d: %s\\n\", i, item_print);\n       ", "distance": 0.4647058823529412}}, {"label": "Human", "text": "     }\n        printf(\"%d: %s\\n\", i, str);\n        i++;\n        current = current->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_print", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    node *newNode = (node*)malloc(sizeof(node));\n    newNode->item_name = item_name;\n    newNode->price = price;\n    newNode->quantity = quantity;\n    newNode->next = NULL;\n    if ((head == NULL) || (*head == NULL)){\n        *head = newNode;\n        return EXIT_SUCCESS;\n    }\n    node *current = *head;\n    int i = 1;\n    while (i < pos-1 && current->next != NULL){\n        current = current->next;\n        i++;\n    }\n    if (i == pos-1){\n        newNode->next = current->next;\n        current->next = newNode;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    if ((head == NULL) || (*head == NULL)){\n        return EXIT_FAILURE;\n    }\n    node *current = *head;\n    int i = 1;\n    while (i < pos && current != NULL){\n        current = current->ne", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "CodexApproximate", "text": "xt;\n        i++;\n    }\n    if (current == NULL) {\n        return EXIT_FAILURE;\n    }\n    current->item_name = item_name;\n    current->price = price;\n    current->quantity = quantity", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-04-30T05:51:50.144Z", "text": "EXIT_FAILURE;\n    }\n    if (str == NULL) {\n        return EXIT_FAILURE;\n    }\n    char *item_name = head->item_name;\n    float price = head->price;\n    int quantity = head->quantity", "distance": 0.3370165745856354}}, {"label": "Human", "text": ";\n    return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_remove_item_at_pos(node **head, int pos) {    \n    if ((head == NULL) || (*head == NULL)) {\n        return EXIT_FAILURE;\n    }\n    int i = 1;\n    node *current = *head;\n    node *prev = NULL;\n    while (i < pos && current != NULL) {\n        prev = current;\n        current = current->next;\n        i++;\n    }\n    if (current == NULL) {\n        return EXIT_FAILURE;\n    }\n    if (prev == NULL) {\n        *head = current->next;\n    } else {\n        prev->next = current->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    if ((head == NULL) || (*head == NULL) || (pos1 == 0) || (pos2 == 0)) {\n        return EXIT_FAILURE;\n    }\n    if (pos1 == pos2) {\n        return EXIT_SUCCESS;\n    } else if (pos1 > pos2) {\n        int temp = pos1;\n        pos1 = pos2;\n        pos2 = temp;\n    }\n    int i = 1;\n    node *current = *head;\n    while (i < pos1 && current != NULL) {\n        current = current->next;\n        i++;\n    }\n    if (current == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *item1 = current;\n    while (i < pos2 && current != NULL) {\n        current = current->next;\n        i++;\n    }\n    if (current == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *item2 = current;\n   ", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": " int temp_quantity = item1->quantity;\n    float temp_price = item1->price;\n    char *temp_item_name = item1->item_name;\n    item1->quantity = item2->quantity;\n    item1->price", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-30T23:06:43.554Z", "text": "item1->quantity = item2->quantity;\n    item1->price = item2->price;\n    item1->item_name = item2->item_name;\n    item2->quantity = temp_quantity;\n    item2->price = temp_price", "distance": 0.26857142857142857}}, {"label": "Codex", "text": " = item2->price;\n    item1->item_name = item2->item_name;\n    item2->quantity = temp_quantity;\n    item2->price = temp_price;\n    item2->item_name = temp_item_name;\n   ", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-04-30T23:07:04.439Z", "text": " = item2->price;\n    item1->item_name = item2->item_name;\n    item2->quantity = temp_quantity;\n    item2->price = temp_price;\n    item2->item_name = temp_item_name;\n   "}}, {"label": "Human", "text": " return EXIT_SUCCESS;\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_find_highest_price_item_position(node *head, int *pos) {\n    if ((head == NULL) || (pos == 0)) {\n        return EXIT_FAILURE;\n    }\n    float max_price = 0.0;\n    int max_pos = 0;\n    int i = 1;\n    node *current = head;\n    while (current != NULL) {\n        if (current->price > max_price) {\n            max_price = current->price;\n            max_pos = i;\n        }\n        current = current->next;\n        i++;\n    }\n    *pos = max_pos;\n    return EXIT_SUCCESS;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_cost_sum(node *head, float *total) {\n    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n    float total_cost = 0.0;\n    node *current = head;\n    while (current != NULL) {\n        total_cost += current->quantity * current->price;\n        current = current->next;\n    }\n    *total = total_cost;\n    return EXIT_SUCCESS;\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "    if ((head == NULL) || (filename == NULL)) {\n        return EXIT_FAILURE;\n    }\n    FILE *ptr = fopen(filename, \"w\");", "function": "list_save", "extra_info": null}, {"label": "CodexApproximate", "text": "\n    node *current = head;\n    while (current != NULL) {\n        char str[MAX_ITEM_PRINT_LEN] = \"\";\n        sprintf(str, \"%s,%.2f,%d\\n\", current->item_name, curre", "function": "list_save", "extra_info": {"ts": "2022-04-30T07:08:59.099Z", "text": "\n    node *curr = head;\n    while (curr != NULL) {\n        char str[MAX_ITEM_PRINT_LEN];\n        if (list_item_to_string(curr, str) == EXIT_FAILURE) {\n           ", "distance": 0.41975308641975306}}, {"label": "Human", "text": "nt->price, current->quantity);\n        fwrite(str, strlen(str), 1, ptr);\n        current = current->next;\n    }\n    fclose(ptr);\n    return EXIT_SUCCESS;\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_load(node **head,", "function": "list_load", "extra_info": null}, {"label": "CodexApproximate", "text": " char *filename) {\n    if (filename == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *current = *head;\n    if ((current != NULL) && (current->next != NULL)) {\n        current = current", "function": "list_load", "extra_info": {"ts": "2022-04-30T22:48:24.543Z", "text": "if ((head == NULL) || (*head == NULL)){\n        return EXIT_FAILURE;\n    }\n    node *current = *head;\n    int i = 1;\n    while (i < pos-1 && current->next != NULL){\n        current = current", "distance": 0.30526315789473685}}, {"label": "Human", "text": "->next;\n    }\n    FILE *ptr = fopen(filename, \"r\");\n    char line[MAX_ITEM_PRINT_LEN];\n    while (fgets(line, sizeof(line), ptr)) {\n        line[strcspn(line, \"\\n\")] = 0;\n        node *newNode = (node*)malloc(sizeof(node));\n        newNode->item_name = strdup(strtok(line, \",\"));\n        newNode->price = atof(strtok(NULL, \",\"));\n        newNode->quantity = atoi(strtok(NULL, \",\"));\n    ", "function": "list_load", "extra_info": null}, {"label": "CodexApproximate", "text": "    newNode->next = NULL;\n        if (*head == NULL) {\n            *head = newNode;\n            current = *head;\n        } else {\n            current->next = newNode;\n         ", "function": "list_load", "extra_info": {"ts": "2022-04-30T06:46:20.477Z", "text": "\n    newNode->next = NULL;\n    if ((head == NULL) || (*head == NULL)){\n        *head = newNode;\n        return EXIT_SUCCESS;\n    }\n    node *current = *head;\n    int i = 0;\n   ", "distance": 0.45454545454545453}}, {"label": "Human", "text": "   current = current->next;\n        }\n    }\n    fclose(ptr);\n    return EXIT_SUCCESS;\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_deduplicate(node **head) {\n  ", "function": "list_deduplicate", "extra_info": null}, {"label": "CodexApproximate", "text": "  if ((head == NULL) || (*head == NULL)) {\n        return EXIT_FAILURE;\n    }\n    node *current = *head;\n    node *possible_dup = NULL;\n    node *prev_possible_dup = NULL;\n    while (current", "function": "list_deduplicate", "extra_info": {"ts": "2022-04-30T22:48:51.349Z", "text": "if ((head == NULL) || (*head == NULL)){\n        return EXIT_FAILURE;\n    }\n    node *current = *head;\n    int i = 1;\n    while (i < pos-1 && current->next != NULL){\n        current = current", "distance": 0.34210526315789475}}, {"label": "Human", "text": " != NULL) {\n        possible_dup = current->next;\n        prev_possible_dup = current;\n        while (possible_dup != NULL) {\n            if (strcmp(current->item_name, possible_dup->item_name) == 0) {\n                // doesn't say to check if the prices are same or not\n                current->quantity += possible_dup->quantity;\n                prev_possible_dup->next = possible_dup->next;\n            }\n            prev_possible_dup = possible_dup;\n            possible_dup = possible_dup->next;\n        }\n        current = current->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 3108, "matched_exact": 168, "matched_approx": 1244, "matched_human": 4579, "matched_total": 9099, "suggestions_matched": 1, "suggestions_approx": 7, "suggestions_total": 12, "suggestions_with_funcs": 11}}
{"uuid": "fd621e01-4962-4699-b49a-012c08563cb5", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    sprintf(str, \"%d * %s @ $%0.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    node *curr = head;\n    int pos = 1;\n    while (curr != NULL) {\n        printf(\"%d: \", pos);\n        char str[MAX_ITEM_PRINT_LEN];\n        list_item_to_string(curr, str);\n        // printf(str);\n        printf(\"\\n\");\n        curr = curr->next;\n        pos++;\n    }\n    return EXIT_SUCCESS;\n}\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "\n// insert an item into the list\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_insert(node **head, int quantity, char *item_name, float price)\n{\n", "function": "list_insert", "extra_info": null}, {"label": "Template", "text": "    return EXIT_FAILURE;\n}\n", "function": "list_insert", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    // return EXIT_SUCCESS;\n    unsigned int count = 1;\n    node *new_item = (node*) malloc(sizeof(node));\n    new_item->item_name = item_name;\n    new_item->price = price;\n    new_item->quantity = quantity;\n    new_item->next = NULL;\n    if (pos == 1) {\n        ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "new_item->next = *head;\n        *head = new_item;\n        return EXIT_SUCCESS;\n    }\n    node *current = *head;\n    while (count < pos - 1 && current != NULL) {\n        current = current->next;", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-13T00:52:33.576Z", "text": "new_item->next = *head;\n        *head = new_item;\n        return EXIT_SUCCESS;\n    }\n    node *current = *head;\n    while (count < pos - 1 && current != NULL) {\n        current = current->next;"}}, {"label": "Human", "text": "\n        count++;\n    }\n    new_item->next = current->next;\n    current->next = new_item;\n    return EXIT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    // unsigned int count = 0;\n    // while (count < pos) {\n    //     head = head->next;\n    //     count++;\n    // }\n    // if (head == NULL) {\n    //     return EXIT_FAILURE;\n    // }\n    // *head->item_name = item_name;\n    // *head->price = price;\n    // *head->quantity = quantity;\n    // return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_find_highest_price_item_position(node *head, int *pos) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_cost_sum(node *head, float *total)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_load(node **head, char *filename)\n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n    // TODO: Implement this function, \n    // return EXIT_SUCCESS or EXIT_FAILURE when appropriate\n    return EXIT_FAILURE;\n}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 4648, "matched_exact": 193, "matched_approx": 0, "matched_human": 1209, "matched_total": 6050, "suggestions_matched": 1, "suggestions_approx": 0, "suggestions_total": 5, "suggestions_with_funcs": 4}}
{"uuid": "ff36e2ef-af58-426f-97ae-dc8ba80ff4a0", "parts": [{"label": "Template", "text": "#include <stdio.h> \n#include <stdlib.h>\n#include <getopt.h>\n#include <string.h>\n#include \"list.h\"\n", "function": null, "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n#ifdef UNIT_TESTING\n/* Redirect printf to a function in the test application so it's possible to\n * test the standard output. You can ignore this; it's not relevant to the\n * assignment. */\n#ifdef printf\n#undef printf\n#endif /* printf */\nextern int test_printf(const char *format, ...);\n#define printf test_printf\n#endif\n\n#define MAX_ITEM_PRINT_LEN 100\n\n// Note: All list_ functions should return a status code\n// EXIT_FAILURE or EXIT_SUCCESS to indicate whether the operation was \n// successful or not.\n\n// create a new list\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_init(node **head)\n{\n    *head = NULL;\n    return EXIT_SUCCESS;\n}\n", "function": "list_init", "extra_info": null}, {"label": "Template", "text": "\n// print a single list item to an externally allocated string\n// This should be in the format of:\n// \"quantity * item_name @ $price ea\", where item_name is a string and \n// price is a float formatted with 2 decimal places.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_item_to_string(node *head, char *str) {\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "    if (head == NULL) {\n        return EXIT_FAILURE;\n    }\n\n    if (head->quantity ==", "function": "list_item_to_string", "extra_info": null}, {"label": "CodexApproximate", "text": " 1) {\n        sprintf(str, \"%d * %s @ $%.2f each\", head->quantity, head->item_name, head->price);\n    } else {\n        sprintf(str, \"%d * %s @ $%.2f each\", head->quant", "function": "list_item_to_string", "extra_info": {"ts": "2022-04-30T23:36:46.013Z", "text": " {\n        sprintf(str, \"%d * %s @ $%.2f each\", head->data->quantity, head->data->name, head->data->price);\n    }\n    return EXIT_SUCCESS;\n}\n\n// print a list to stdout", "distance": 0.4431137724550898}}, {"label": "Human", "text": "ity, head->item_name, head->price);\n    }\n    return EXIT_SUCCESS;\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_item_to_string", "extra_info": null}, {"label": "Human", "text": "\n// print a list to stdout\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// print the list to stdout\n// This should be in the format of:\n// \"pos: quantity * item_name @ $price ea\", where \n//   pos is the position of the item in the list, \n//   item_name is the item_name of the item and \n//   price is the float price of the item formatted with 2 decimal places.\n// For example:\n// \"\"\"1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// 3: 4 * apple @ $3.00 ea\n// \"\"\"\n// It should return a newline character at the end of each item. \n// It should not have a leading newline character.\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_print(node *head) {\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "    char* strptr;\n    int", "function": "list_print", "extra_info": null}, {"label": "CodexApproximate", "text": " count = 0;\n    node *temp = head;\n\n    while (temp != NULL) {\n        count++;\n        printf(\"%d: \", count);\n        list_item_to_string(temp, strptr);\n        printf(\"\\n\");", "function": "list_print", "extra_info": {"ts": "2022-05-02T20:02:04.957Z", "text": "\n    int cnt = 0;\n    node *temp = head;\n\n    while (temp != NULL) {\n        cnt++;\n        printf(\"%d: \", cnt);\n        list_item_to_string(temp, str);\n        printf(\"\\n\");\n", "distance": 0.09714285714285714}}, {"label": "Human", "text": "\n        temp = temp->next;\n    }\n\n    return EXIT_SUCCESS;\n}\n", "function": "list_print", "extra_info": null}, {"label": "Human", "text": "\n// Append a new item to the end of the list.\n// This \n\n\n// free all memory used by the list\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_free(node ** n){\n    ", "function": "list_free", "extra_info": null}, {"label": "Codex", "text": "if (n == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *current = *n;\n    node *next;\n\n    while (current != NULL) {\n        next = current->next;\n        free(current->item_name);\n", "function": "list_free", "extra_info": {"ts": "2022-05-02T19:45:53.045Z", "text": "if (n == NULL) {\n        return EXIT_FAILURE;\n    }\n    node *current = *n;\n    node *next;\n\n    while (current != NULL) {\n        next = current->next;\n        free(current->item_name);\n"}}, {"label": "Human", "text": "        free(current);\n        current = next;\n    }\n\n    *n = NULL;\n    return EXIT_SUCCESS;\n", "function": "list_free", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_free", "extra_info": null}, {"label": "Human", "text": "\n// add an item to the end of the list\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_append(node **head, char *item_name, float price)\n{}\n", "function": "list_append", "extra_info": null}, {"label": "Template", "text": "\n// add a new item (name, price, quantity) to the list at position pos, \n//   such that the added item is the item at position pos\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1.00 ea\n// 2: 2 * orange @ $2.00 ea\n// and you call list_add_item_at_pos(&head, \"apple\", 3.0, 4, 2)\n// the list should be:\n// 1: 3 * banana @ $1.00 ea\n// 2: 4 * apple @ $3.00 ea\n// 3: 2 * orange @ $2.00 ea\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_add_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos){\n    ", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "node *curr = *head;\n    node *prev = NULL;\n    node *new_item = NULL;\n\n    new_item = malloc(sizeof(node));\n    if (new_item == NULL) {\n        return EXIT_FAILURE;\n   ", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-02T19:39:02.260Z", "text": "node *curr = *head;\n    node *prev = NULL;\n    node *new_item = NULL;\n\n    new_item = malloc(sizeof(node));\n    if (new_item == NULL) {\n        return EXIT_FAILURE;\n   "}}, {"label": "CodexApproximate", "text": " }\n    new_item->item_name = item_name;\n    new_item->price = price;\n    new_item->quantity =quantity;\n    new_item->next = NULL;\n\n    // Special cases\n    if (pos == 0) {\n        new", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-04-30T23:19:00.769Z", "text": "(node *) malloc(sizeof(node));\n    newNode->item_name = item_name;\n    newNode->price = price;\n    newNode->quantity = quantity;\n    newNode->next = NULL;\n    // TODO: Implement this ", "distance": 0.4808743169398907}}, {"label": "Codex", "text": "_item->next = curr;\n        *head = new_item;\n        return EXIT_SUCCESS;\n    }\n    if (pos > list_length(*head)) {\n        return EXIT_FAILURE;\n    }\n\n    curr = *head", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-02T19:40:00.535Z", "text": "_item->next = curr;\n        *head = new_item;\n        return EXIT_SUCCESS;\n    }\n    if (pos > list_length(*head)) {\n        return EXIT_FAILURE;\n    }\n\n    curr = *head"}}, {"label": "Codex", "text": ";\n    for (unsigned int i = 0; i < pos; i++) {\n        prev = curr;\n        curr = curr->next;\n    }\n    prev->next = new_item;\n    new_item->next = curr;\n    return EX", "function": "list_add_item_at_pos", "extra_info": {"ts": "2022-05-02T19:40:10.572Z", "text": ";\n    for (unsigned int i = 0; i < pos; i++) {\n        prev = curr;\n        curr = curr->next;\n    }\n    prev->next = new_item;\n    new_item->next = curr;\n    return EX"}}, {"label": "Human", "text": "IT_SUCCESS;\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_add_item_at_pos", "extra_info": null}, {"label": "Human", "text": "\n// add a new item (name, price, quantity) to the list, such that the added item\n//   is the first item in the list\n// For example:\n// If the list is:\n// 1: 3 * banana @ $1\n\n", "function": null, "extra_info": null}, {"label": "Template", "text": "\n// update the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_update_item_at_pos(node **head, char *item_name, float price, int quantity, unsigned int pos) {\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "node *curr = *head;\n    node *prev = NULL;\n\n    // Special cases\n    if (pos == 0) {\n        curr->item_name = item_name;\n        curr->price = price;\n        curr->quantity = quantity;\n", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-02T20:07:01.295Z", "text": "node *curr = *head;\n    node *prev = NULL;\n\n    // Special cases\n    if (pos == 0) {\n        curr->item_name = item_name;\n        curr->price = price;\n        curr->quantity = quantity;\n"}}, {"label": "Codex", "text": "        return EXIT_SUCCESS;\n    }\n    if (pos > list_length(*head)) {\n        return EXIT_FAILURE;\n    }\n\n    curr = *head;\n    for (unsigned int i = 0; i < pos; i++) {", "function": "list_update_item_at_pos", "extra_info": {"ts": "2022-05-02T20:07:18.501Z", "text": "        return EXIT_SUCCESS;\n    }\n    if (pos > list_length(*head)) {\n        return EXIT_FAILURE;\n    }\n\n    curr = *head;\n    for (unsigned int i = 0; i < pos; i++) {"}}, {"label": "Human", "text": "\n        prev = curr;\n        curr = curr->next;\n    }\n    prev->item_name = item_name;\n    prev->price = price;\n    prev->quantity = quantity;\n    return EXIT_SUCCESS;\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_update_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// remove the item at position pos\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_remove_item_at_pos(node **head, int pos)\n{    \n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Human", "text": "    ", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Codex", "text": "node *curr = *head;\n    node *prev = NULL;\n    int count = 0;\n\n    // Special cases\n    if (pos == 0) {\n        *head = curr->next;\n        free(curr->item_name);\n        free(cur", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-05-02T20:10:50.633Z", "text": "node *curr = *head;\n    node *prev = NULL;\n    int count = 0;\n\n    // Special cases\n    if (pos == 0) {\n        *head = curr->next;\n        free(curr->item_name);\n        free(cur"}}, {"label": "Codex", "text": "r);\n        return EXIT_SUCCESS;\n    }\n    if (pos > list_length(*head)) {\n        return EXIT_FAILURE;\n    }\n\n    curr = *head;\n    for (unsigned int i = 0; i < pos;", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-05-02T20:10:54.776Z", "text": "r);\n        return EXIT_SUCCESS;\n    }\n    if (pos > list_length(*head)) {\n        return EXIT_FAILURE;\n    }\n\n    curr = *head;\n    for (unsigned int i = 0; i < pos;"}}, {"label": "Codex", "text": " i++) {\n        prev = curr;\n        curr = curr->next;\n    }\n    prev->next = curr->next;\n    free(curr->item_name);\n    free(curr);\n    return EXIT_SUCCESS;\n", "function": "list_remove_item_at_pos", "extra_info": {"ts": "2022-05-02T20:10:59.172Z", "text": " i++) {\n        prev = curr;\n        curr = curr->next;\n    }\n    prev->next = curr->next;\n    free(curr->item_name);\n    free(curr);\n    return EXIT_SUCCESS;\n"}}, {"label": "Template", "text": "}\n", "function": "list_remove_item_at_pos", "extra_info": null}, {"label": "Template", "text": "\n// swap the item at position pos1 with the item at position pos2\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_swap_item_positions(node **head, int pos1, int pos2) {\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Human", "text": "    node *curr = *head;\n    node *prev = NULL;\n    node *temp = NULL;", "function": "list_swap_item_positions", "extra_info": null}, {"label": "CodexApproximate", "text": "\n    int count = 0;\n    // Special cases\n    if (pos1 == pos2) {\n        return EXIT_SUCCESS;\n    }\n    else{\n        *head = curr->next;\n        temp = curr;\n        curr", "function": "list_swap_item_positions", "extra_info": {"ts": "2022-05-02T20:33:26.143Z", "text": "// Special cases\n    if (pos1 == pos2) {\n        return EXIT_SUCCESS;\n    }\n    if (pos1 == 0 && pos2 == 1) {\n        *head = curr->next;\n        temp = curr;\n        curr", "distance": 0.2982456140350877}}, {"label": "Human", "text": " = curr->next;\n        temp->next = curr->next;\n        curr->next = temp;\n        return EXIT_SUCCESS;\n    }\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_swap_item_positions", "extra_info": null}, {"label": "Template", "text": "\n// find the item position with the highest single price\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_find_highest_price_item_position(node *head, int *pos) {\n    node* curr = head;\n    int highest_price = curr->price;\n    for (unsigned int i = 0; i < pos; i++) {\n        if(curr->price > highest_price)  \n            {highest_price = curr->price;}\n        curr = curr->next;\n    }\n    return highest_price;\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_find_highest_price_item_position", "extra_info": null}, {"label": "Template", "text": "\n// calculate the total cost of the list (sum of all prices * quantities)\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_cost_sum(node *head, float *total){\n    node *curr = head;\n    while(curr != NULL){\n        total += (curr->price * curr->quantity);\n        curr = curr->next;\n    }\n    return total;\n    \n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_cost_sum", "extra_info": null}, {"label": "Template", "text": "\n// save the list to file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_save(node *head, char *filename)\n", "function": "list_save", "extra_info": null}, {"label": "Human", "text": "{   \n    \n    FILE *f = fopen(strcat(filename, \".txt\"), \"w\");\n    if(f==NULL){\n        printf(\"Error opening file\");\n        return EXIT_FAILURE;\n    }\n\n    node *temp = head;\n    char* strptr;\n\n    while (temp != NULL) {\n        if (head == NULL)", "function": "list_save", "extra_info": null}, {"label": "CodexApproximate", "text": " \n            {return EXIT_FAILURE;}\n        fprintf(f, \"%d * %s @ $%.2f each\", head->quantity, head->item_name, head->price);\n        temp = temp->next;\n ", "function": "list_save", "extra_info": {"ts": "2022-04-30T23:08:59.050Z", "text": "\n    if(head == NULL) return EXIT_FAILURE;\n    sprintf(str, \"%d * %s @ $%.2f ea\", head->quantity, head->item_name, head->price);\n    return EXIT_SUCCESS;\n}", "distance": 0.3032258064516129}}, {"label": "Human", "text": "   }\n    return EXIT_SUCCESS;\n\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_save", "extra_info": null}, {"label": "Template", "text": "\n// load the list from file filename\n// the file should be in the following format:\n// item_name,price,quantity\\n \n//   (one item per line, separated by commas, and newline at the end)\n// the loaded values are added to the end of the list\n", "function": null, "extra_info": null}, {"label": "Human", "text": "int list_load(node **head, char *filename){\n    node* temp = (struct node *)malloc(sizeof(node));;\n    node* head; \n    node* last; \n    last = head = NULL;\n    \n    FILE* file;\n    file = fopen (strcat(filename, \".txt\"), \"r\");\n    if (file == NULL)\n    {\n        fprintf(stderr, \"\\nCouldn't Open File'\\n\");\n        return EXIT_FAILURE;\n    }\n    \n    while(fread(temp, sizeof(node), 1, file)){        \n        if(head==NULL)\n            {head = last = (struct node *)malloc(sizeof(node));}\n        else{\n            last->next = (struct node *)malloc(sizeof(node));\n            last = last->next;\n        }\n        last->quantity = temp->quantity;\n        last->price = temp->price;\n        strcpy(last->item_name, temp->item_name);\n        last->next = NULL;\n    }\n    \n    fclose(file);\n    return EXIT_SUCCESS;\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "}\n", "function": "list_load", "extra_info": null}, {"label": "Template", "text": "\n// de-duplicate the list by combining items with the same name \n//    by adding their quantities\n// The order of the returned list is undefined and may be in any order\n", "function": null, "extra_info": null}, {"label": "Template", "text": "int list_deduplicate(node **head) \n{\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "    node *ptr1, *ptr2, *dup;\n    ptr1 = head;\n \n    while (ptr1 != NULL && ptr1->next != NULL) {\n        ptr2 = ptr1;\n        while (ptr2->next != NULL) {\n            /* If duplicate then delete */\n            if (strcmp(ptr1->item_name, ptr2->next->item_name)==0) {\n                dup = ptr2->next;\n                ptr2->next = ptr2->next->next;\n                delete (dup);\n            }\n            else \n                {ptr2 = ptr2->next;}\n        }\n        ptr1 = ptr1->next;\n    }\n    return EXIT_SUCCESS;\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Template", "text": "\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "}\n", "function": "list_deduplicate", "extra_info": null}, {"label": "Human", "text": "\n", "function": null, "extra_info": null}], "matchdata": {"matched_template": 3095, "matched_exact": 1551, "matched_approx": 851, "matched_human": 3356, "matched_total": 8853, "suggestions_matched": 9, "suggestions_approx": 5, "suggestions_total": 33, "suggestions_with_funcs": 24}}
